create or replace package app_utils is
  --
  procedure clear_user_env;
  function get_user_id return varchar2;
  function get_user_name return varchar2;
  procedure init_user_env(p_user_rec app_users%rowtype, p_ip varchar2);
  procedure init_user_env(p_user_id app_users.user_id%type);

  /*
  function c_notif_scheduled     return number;
  function c_notif_successful    return number;
  function c_notif_failed        return number;
  function c_notif_expired       return number;
  ----------------------------------------------------------------------------------------------------------------------
  function c_notif_expiry_period return number;
  ----------------------------------------------------------------------------------------------------------------------
  function c_mixed_group_flag             return varchar2;
  function c_email_contact_code           return varchar2;
  function c_max_date                     return date;
  function c_file_directory               return varchar2;
  --
  function c_invoice_template_type        return varchar2;
  function c_credit_note_template_type    return varchar2;
  function c_inv_det_template_type        return varchar2;
  function c_cr_note_det_template_type    return varchar2;
  function c_rat_exp_template_type        return varchar2;
  function c_rat_rcn_template_type        return varchar2;
  function c_rat_rcn_letter               return varchar2;
  function c_rat_ana_exp_template_type    return varchar2;
  function c_invoice_letter               return varchar2;
  function c_invoice_det_letter           return varchar2;
  function c_credit_note_letter           return varchar2;
  function c_rate_exp_letter              return varchar2;
  function c_sms_rate_exp_template_type   return varchar2;
  function c_sms_rate_exp_letter          return varchar2;
  function c_credit_usage_template        return varchar2;
  function c_balance_alert_template       return varchar2;
  function c_fin_deffered_pay_letter      return varchar2;
  function c_sta_cdr_export_letter        return varchar2;
  function c_sta_rerate_letter            return varchar2;
  function c_trd_blend_route_change       return varchar2;
  function c_trd_blend_not_active_letter  return varchar2;
  function c_clp_new_carrier_letter       return varchar2;
  function c_clp_new_payment_letter       return varchar2;
  function c_clp_failed_payment_letter    return varchar2;
  function c_clp_reverse_payment_letter   return varchar2;
  function c_sms_edr_export_letter        return varchar2;
  --
  function c_fin_pay_in_letter            return varchar2;
  function c_fin_pay_out_letter           return varchar2;
  --
  function c_ntf_type_tech                return varchar2;
  function c_ntf_type_acc                 return varchar2;
  function c_ntf_type_rate                return varchar2;
  function c_ntf_type_inv                 return varchar2;
  --
  function c_clp_activate_letter          return varchar2;
  function c_clp_register_letter          return varchar2;
  function c_clp_cdr_exp_letter           return varchar2;
  function c_clp_edr_exp_letter           return varchar2;
  --User security for portal users
  function c_clp_user_reset_pwd_letter    return varchar2;
  function c_clp_user_update_pwd_letter   return varchar2;
  function c_clp_user_error_pwd_letter    return varchar2;
  --User security for system owner users
  function c_bas_user_reset_pwd_letter    return varchar2;
  function c_bas_user_expire_pwd_letter   return varchar2;
  function c_bas_user_update_pwd_letter   return varchar2;
  function c_bas_user_error_pwd_letter    return varchar2;
  --
  function c_clp_campaign_start           return varchar2;
  --
  function c_rut_lim_letter               return varchar2;
  --
  function c_sep       return char;
  function c_dir_name  return varchar2;
  --
  --of kind template type
  function c_tmpl_type_file       return bas_template_type.template_format%type;
  function c_tmpl_type_mail       return bas_template_type.template_format%type;
  --
  function c_tmpl_hand_embed_poi  return bas_template.template_handler%type;
  function c_tmpl_hand_docproc    return bas_template.template_handler%type;
  function c_tmpl_cont_xls        return bas_template.template_content_type%type;
  function c_tmpl_cont_xlsx       return bas_template.template_content_type%type;
  function c_tmpl_cont_mail       return bas_template.template_content_type%type;
  --
  --Predefined oracle users
  function c_uidisp_un     return varchar2;
  function c_hwdisp_un     return varchar2;
  function c_api_un        return varchar2;
  --
  function get_user_timezone return number;
  --
  function get_extented_user_info return varchar2;
  procedure set_product_list(p_user_id  bas_user.user_id%type);


  procedure enable_disable_vpd(p_action varchar2);

  / **
  * Логин в систему. Метод предназначен для переходного периода на новый API, для вызова из веба взамен старой функции.
  * После того, как uidisp полностью перейдет на новый API, procedure login нужно будет модернизировать в function login,
  * а от этого метода нужно будет избавиться.
  * @param p_names Параметры фильтрации:
  * <ul>
  *   <li/>'user_name',  // имя пользователя
  *   <li/>'password',  // пароль
  *   <li/>'ip',  // необязательная переменная - IP адрес клиента
  *   <li/>'lang',  // необязательная переменная - язык логина в систему [ENG;RUS;ITA;ESP] - поддерживаемые на данный момент языки. Если язык не задан, то берется значение из bas_user.user_lang
  * </ul>
  * @param p_values
  * @return
  * <ol>
  *   <li/>sid - session id in oracle
  * </ol>
  * /
  function login(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return varchar2;

  / **
  * Логин
  * @param p_user_name имя пользователя
  * @param p_password пароль
  * @param p_sid сессии
  * @param p_ip необязательная переменная - IP адрес клиента
  * @param p_lang необязательная переменная, заполняется значением из списка [ENG;RUS;ITA;ESP] - поддерживаемые на данный момент языки. Если язык не задан, то берется значение из bas_user.user_lang
  * /
  procedure login(p_user_name varchar2, p_password varchar2, p_sid out varchar2, p_ip varchar2, p_lang varchar2 := null);

  procedure logout;

  procedure check_auth;

  function get_cc_id(p_car_id bas_carrier.car_id%type) return number;

  / **
  * Внутренний БД метод для запроса смены пароля
  * /
  procedure request_password_reset(p_name_or_email varchar2, p_link varchar2);

  / **
  * Метода запроса смены пароля для inVoice core (wrapper)
  * @param p_names Параметры
  * <ul>
  *   <li/>name_or_email[*],  //Логин-нейм или еmail пользователя, который должен сбросить пароль
  *   <li/>link,        //Ссылка для перехода из письма, по умолчанию ссылка будет сформирована в соотв. с параметрами пользователя
  * </ul>
  * /
  procedure request_password_reset(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);

  / **
  * Метод для смены пароля с использованием ключа, переданного по электронной почте, метод не требует авторизации inVoice core (wrapper)
  * @param p_names Параметры
  * <ul>
  *   <li/>key - ключ
  *   <li/>new_pwd - новый пароль
  * </ul>
  * /
  procedure change_password_using_key(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);

  / **
  * Метод для смены пароля с использованием ключа, переданного по электронной почте, метод не требует авторизации
  * @param p_key - ключ
  * @param p_new_pwd - новый пароль
  * /
  procedure change_password_using_key(p_key varchar2, p_new_pwd varchar2);

  / **
  * Метод для смены пароля с использованием старого пароля, предполагается, что пользователь авторизован
  * @param p_old_pwd - старый пароль
  * @param p_new_pwd - новый пароль
  * /
  procedure change_password_using_old_pwd(p_old_pwd varchar2, p_new_pwd varchar2);

  procedure set_user_lang(p_lang varchar2);

  function get_user_lang return sys_refcursor;

  / **
  * Процедура сохранения пользовательских настроек в формате json
  * @param p_settings_json - json объект содержащий настройки авторизованного пользователя. Некорректный json игнорируется.
  * /
  procedure set_user_settings(p_settings_json varchar2);

  / **
  * Функция получения пользовательских настроек в формате json
  * @return json объект содержащий настройки авторизованного пользователя
  * /
  function get_user_settings return varchar2;  

  procedure update_menu_item
  (
    p_item_code         varchar2,
    p_parent_item_code  varchar2,
    p_role_code         varchar2,
    p_item_type         varchar2,
    p_item_order        number default null
  );

  procedure delete_menu_item(p_menu_item_code varchar2);

  / **
  * Процедура обновления справочника валют
  * @param p_names Параметры фильтрации:
  *   <ul>
  *     <li/>currency_code - краткое название валюты, является ключом для многих сущностей,
  *     <li/>currency_id - числовой код валюты. Если передавать его null, то запись будет создана вновь,
  *     <li/>currency_display_name - полное название валюты
  *   </ul>
  * /
  procedure update_currency(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);

  / **
  * Процедура обновления курсов валют
  * @param p_names Параметры фильтрации:
  *   <ul>
  *     <li/>new_currency_code - новое значение кода валюты,
  *     <li/>old_currency_code - старое значение кода валюты (если update),
  *     <li/>new_currency_date - новое значение даты действия курса,
  *     <li/>old_currency_date - старое значение даты действия курса (если update),
  *     <li/>new_currency_rate - новое значение курса валют
  *     <li/>new_spread_pct    - спрэд в процентах Bug#5703
  *   </ul>
  * /
  procedure update_currency_rate(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);

  procedure delete_currency_rate(p_currency_code varchar2, p_date date);

  / **
  * Процедура удаления данных
  * @param p_currency_id краткое название валюты, является ключом для многих сущностей
  * /
  procedure delete_currency(p_currency_id number);


  / **
  * Функция получения текущего курса валют
  * @param p_currency_code  - код валюты
  * @param p_date           - дата
  * @param p_leg            - опциональное указание лега для прибавления или удаления спреда. 0 - спрэд вычитается, 1 - прибавляется
  * /
  function get_currency_rate(p_currency_code varchar2, p_date date, p_leg number := null) return number result_cache;

  / **
  * Получение списка валют в системе
  * @return
  *     <ol>
  *         <li/>'product_descr',
  *         <li/>'currency_code', // код валюты
  *         <li/>'currency_id', // числовой код валюты
  *         <li/>'currency_display_name' // полное название валюты
  *     </ol>
  * /
  function get_currency_code_list return sys_refcursor;

  / **
  * Получение списка курсов валют<br/>
  * Примечание:
  * @param p_names
  * <ul>
  *   <li/>currency_code
  *   <li/>from_date
  *   <li/>till_date
  * </ul>
  * Логика метода bas_utils.get_currency_rate_list:<br>
  * если приходит параметры till_date, from_date то отображается история изменения курса согласно настрокам фильтра<br>
  * если параметры till_date и from_date не приходят то отображается последний курс валюты (одна валюта одна строка)<br>
  * @return
  *     <ol>
  *         <li/>'currency_code', - код валюты
  *         <li/>'currency_rate_date', - время последнего обновления валюты
  *         <li/>'currency_rate' - рейт
  *         <li/>'spread_pct' - спрэд в процентах Bug#5703
  *         <li/>'show_actual_rates' - показывать рейты только на текущую дату (возможные значения 1,null)
  *     </ol>
  * /
  function get_currency_rate_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  function convert_currency
  (
    p_amount              number,
    p_from_currency_code  varchar2,
    p_to_currency_code    varchar2 := prv_var.c_server_currency_code,
    p_date                date := sysdate,
    p_timezone            number := nvl(sys_context('user_ctx', 'user_time_offset'), 0),
    p_leg                 number := null
  ) 
  return number;

  function get_currency_decode(p_currency_code varchar2, p_date date) return varchar2;

  --
  / **
  * Апдейт одного диалкода
  * /
  procedure update_dial_code(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);

  / **
  * Групповой апдейт диалкодов
  * @param p_names Параметры фильтрации:
  *   <ul>
  *     <li/>'multiedit_ids',
  *     <li/>'multiedit_selection_mode'
  *   </ul>
  * @param p_values
  * @param p_upd_names
  *   <ul>
  *     <li/>'dial_code', // фильтр по диалкоду
  *     <li/>'dial_code_country', // фильтр по стране
  *     <li/>'dial_code_region', // фильтр по региону
  *     <li/>'dial_code_type', // фильтр по типу
  *     <li/>'new_country', // если задано - обновлять страну для всех отфильтрованных диалкодов
  *     <li/>'new_type', // если задано - обновлять тип для всех отфильтрованных диалкодов
  *     <li/>'new_region' // если задано - обновлять регион для всех отфильтрованных диалкодов
  *   </ul>
  * @param p_upd_values
  * @return
  *   <ol>
  *     <li/>cnt //Строка типа X rows updated. Показав это в мессаджбоксе надо спросить пользователя: Commit или Rollback и вызвать соотв. метод: Session.commit или Session.rollback.
  *   </ol>
  * /
  function batch_update_dial_code
  (
    p_names       dbms_sql.varchar2_table,
    p_values      dbms_sql.varchar2_table,
    p_upd_names   dbms_sql.varchar2_table,
    p_upd_values  dbms_sql.varchar2_table
  )
  return number;

  / **
  * Удаление диалкодов
  * @param p_dial_codes //массив кодов для удаления
  * /
  procedure delete_dial_code(p_dial_codes dbms_sql.varchar2_table);

  / **
  * Получение списка диалкодов
  * @param p_names Параметры фильтрации:
  *     <ul>
  *         <li/>dial_code
  *         <li/>dial_code_country
  *         <li/>dial_code_region
  *         <li/>dial_code_type
  *         <li/>rate_product_id - идентификатор продукта
  *         <li/>first_rec
  *         <li/>rec_count
  *     </ul>
  * @param p_dial_code_list необязательный параметр - список диалкодов для фильтрации
  * @param p_dest_list необязательный параметр - список дестинейшенов для фильтрации
  * @return
  *     <ol>
  *         <li/>'DIAL_CODE', // Код
  *         <li/>'DIAL_CODE_COUNTRY', // Страна
  *         <li/>'DIAL_CODE_REGION', // Регион
  *         <li/>'DIAL_CODE_TYPE', // Тип
  *         <li/>'DIAL_CODE_DESTINATION' // конкатенация страны, Региона, типа
  *         <li/>'CNT' // Кол-во записей в ответе (в первой строчке)
  *     </ol>
  * /
  function get_dial_code_list
  (
    p_names           dbms_sql.varchar2_table,
    p_values          dbms_sql.varchar2_table,
    p_dial_code_list  dbms_sql.varchar2_table default cast(null as dbms_sql.varchar2_table),
    p_dest_list       dbms_sql.varchar2_table default cast(null as dbms_sql.varchar2_table)
  )
  return sys_refcursor;

  / **
  * Экспорт диалкодов.
  * @param p_names Параметры фильтрации. Все параметры как в методе get_dial_code_list, кроме пагинации, которая не нужна. Дополнительный опциональный параметр:
  *     <ul>
  *         <li/>'report_header' // Заголовок в экспорте (внутри файла).
  *     </ul>
  * @return BLOB файла экспорта. Формат - XLS или XLSX - в зависимости от настроек системы.
  * /
  function export_dial_code_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return blob;

  / **
  * Получение списка дестинаций
  * @param p_names Параметры фильтрации:
  *     <ul>
  *         <li/>destination_str - фильтр по дестинации
  *         <li/>product_id - фильтр по продукт ID
  *         <li/>first_rec,rec_count - пагинация
  *     </ul>
  * @return
  *     <ol>
  *         <li/>dial_code_destination - дестинация
  *     </ol>
  * /
  function get_destination_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  --
  / **
  * Возвращает список стран
  * @param Параметры:
  *   <ul>
  *     <li/>country_pattern, // регулярное выражения, для фильтрации вывода
  *     <li/>first_rec, // номер строки начиная с которой надо выводить страницу постраничного вывода
  *     <li/>rec_count, // размер страницы, постраничного вывода
  *   </ul>
  * @param p_values
  * @return
  *   <ul>
  *     <li/>'COUNTRY_ID', // идентификатор страны (int)
  *     <li/>'COUNTRY_NAME', // название страны (string)
  *     <li/>'COUNTRY_REGION_ID', //код глобального региона страны (int)
  *     <li/>'CNT' // общее количество строк (int) (только в первой строке)
  *   </ul>
  * /
  function get_dial_code_country_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  / **
  * Заполнение глобального региона для страны
  * @param p_names Параметры фильтрации:
  *   <ul>
  *     <li/>country_id - ID страны для которой заполняется регион
  *     <li/>region_id
  *   </ul>
  * /
  procedure update_dial_code_country(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);

  / **
  * Справочник регионов внутри страны
  * @param p_names Параметры:
  *   <ul>
  *     <li/>country, // фильтр по стране (если не задан то все)
  *     <li/>region_pattern, // регулярное выражения, для фильтрации регионов по имени
  *     <li/>first_rec, // номер строки начиная с которой надо выводить страницу постраничного вывода
  *     <li/>rec_count // размер страницы, постраничного вывода
  *   </ul>
  * @param p_values
  * @return
  *   <ul>
  *     <li/>'dial_code_region, // название региона (string)
  *     <li/>'dial_code_country, // название страны (string)
  *     <li/>'cnt' // общее количество строк (int) (только в первой строке)
  *   </ul>
  * /
  function get_country_region_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;
  
  / **
  * Справочник регионов
  * @param p_names Параметры:
  *   <ul>
  *     <li/>dial_code_region, // фильтрация регионов по имени
  *     <li/>first_rec, // номер строки начиная с которой надо выводить страницу постраничного вывода
  *     <li/>rec_count // размер страницы, постраничного вывода
  *   </ul>
  * @param p_values
  * @return
  *   <ul>
  *     <li/>'dial_code_region', // название региона (string)
  *     <li/>'cnt' // общее количество строк (int) (только в первой строке)
  *   </ul>
  * /
  function get_dial_code_region_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  / **
  * Справочник типов диалкодов
  * @param p_names Параметры:
  *   <ul>
  *     <li/>type_pattern // регулярное выражения, для фильтрации типов по имени
  *   </ul>
  * @param p_values
  * @return
  *   <ul>
  *     <li/>'type_id', // идентификатор типа (int)
  *     <li/>'type_name', // название типа (string)
  *     <li/>'cnt' // общее количество строк (int) (только в первой строке)
  *   </ul>
  * /
  function get_dial_code_type_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  / **
  * Справочник кодов стран
  * @param p_names Параметры:
  *   <ul>
  *     <li/>country, //фильтр по стране
  *     <li/>country_dial_code //фильтр по коду страны
  *     <li/>orderby_clause //Одноуровнева сортировка: country|country_dial_code ASC|DESC
  *   </ul>
  * @param p_values
  * @return
  *   <ul>
  *     <li/>'record_id', // идентификатор строчки (int)
  *     <li/>'country', // название страны (string)
  *     <li/>'country_dial_code', // код страны (string)
  *     <li/>'cnt' // общее количество строк (int) (только в первой строке)
  *   </ul>
  * /  
  function get_country_code_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;


  / **
  * Изменение кода страны
  * @param p_names Параметры:
  *   <ul>
  *     <li/>record_id, // идентификатор строчки (int)
  *     <li/>country, // название страны (string)
  *     <li/>country_dial_code, // код страны (string)
  *   </ul>
  * @param p_values
  * /  
  procedure update_country_code(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);

  / **
  * Удаление кода страны
  * @param p_record_id // идентификатор строчки (int)
  * /  
  procedure delete_country_code(p_record_id number);

  --
  function get_carrier_name(p_car_id number) return varchar2;

  / **
  * Получение списка кериеров
  * @param p_names Параметры:
  *   <ul>
  *     <li/>name_pattern фильтр по маске названия кериера, null - все
  *     <li/>direction фильтр по направлению (0 - клиент, 1 - вендор), null - все
  *     <li/>only_allowed если передана 1, то отобраются только действующие кериеры, 0 или null - все
  *     <li/>region_id фильтр по региону, null - все
  *   </ul>
  * @param p_values
  * @return
  *   <ul>
  *     <li/>'car_id',
  *     <li/>'car_name',
  *     <li/>'car_parent_id',
  *     <li/>'have_client_prods', // имеет ли кериер клиентские продукты (любые продукты, не обязательно голосовые)
  *     <li/>'have_vendor_prods', // имеет ли кериер вендорские продукты
  *     <li/>'country_node_id', // ссылка на код страны из реестра
  *     <li/>'car_is_active',
  *     <li/>'have_voice_prods', // имеет ли кериер голосовые продукты
  *     <li/>'have_sms_prods', // имеет ли кериер смс продукты
  *     <li/>'have_sms_client_prods', //имеет ли кериер клиентские смс продукты
  *     <li/>'have_sms_vendor_prods', //имеет ли кериер вендорские смс продукты
  *     <li/>'car_cc_id' // ссылка на юридическое лицо (contract company)
  *   </ul>
  * /
  function get_carrier_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  --
/ **
  * Получение списка продуктов
  * @param p_names Параметры фильтрации:
  *   <ul>
  *     <li/>acc_id - код аккаунта
  *     <li/>car_id - код кериера
  *     <li/>direction - направление (0 - клиент, 1 - вендор)
  *     <li/>car_name - имя кериера
  *     <li/>product_descr - имя продукта
  *     <li/>type - фильтрация по типу продукта:
  *       <ul>
  *         <li/>null - Все,
  *         <li/>'voip' - Все воипные (и international, и us domestic),
  *         <li/>'sms' - SMS продукты,
  *         <li/>'international' - только интернешнл,
  *         <li/>'usdomestic' - только us domestic.
  *       </ul>
  *     <li/>excl_product_ids список product_id для исключения через запятую
  *     <li/>first_rec - пагинация
  *     <li/>rec_count - пагинация
  *   </ul>
  * @return
  *   <ol>
  *     <li/>'product_id', 
  *     <li/>'product_descr', 
  *     <li/>'parent_product_id', 
  *     <li/>'product_caption', 
  *     <li/>'product_direction',
  *     <li/>'acc_currency_code',
  *     <li/>'product_type',
  *     <li/>'check_lata',
  *     <li/>'agr_timezone_name',
  *     <li/>'car_id',
  *     <li/>'rates_based_on',
  *     <li/>'rate_set_code',
  *     <li/>'def_indeterminate_price',
  *     <li/>'acc_id',
  *     <li/>'car_region_id',
  *     <li/>'car_is_active',
  *     <li/>'billing_mode',
  *     <li/>'increase_period',
  *     <li/>'decrease_period',
  *     <li/>'check_ani_tags',
  *     <li/>'systemid_list', // список имен пользователей каналов (SMS Channel authorization user name), привязанных через POI к этому продукту
  *     <li/>'style', //Стиль колонки
  *     <li/>'acc_car_manager_id', //идентификатор пользователя, являющегося аккаунт менеджером продукта
  *     <li/>'car_cc_id', //идентификатор контракт компани к которой привязан кериер
  *     <li/>'cnt'
  *   </ol>
  * /
  function get_product_list
  (
    p_names             dbms_sql.varchar2_table,
    p_values            dbms_sql.varchar2_table
  )
  return sys_refcursor;

  / **
  * Получение списка описаний продуктов
  * @param p_names Параметры:
  *   <ul>
  *     <li/>'direction', // фильтр клиент/вендорские продукты (null - все, 0 - клиентские, 1 - вендорские)
  *     <li/>'type', // фильтр категории/технологии продукта: voip|sms
  *   </ul>
  * @param p_values
  * @return
  *   <ol>
  *     <li/>'product_descr',
  *     <li/>'have_voice_client_prods', //есть ли для такого descr клиентские голосовые продукты
  *     <li/>'have_voice_vendor_prods' //есть ли для такого descr вендорские голосовые продукты
  *     <li/>'have_sms_client_prods', //есть ли для такого descr клиентские смс продукты
  *     <li/>'have_sms_vendor_prods' //есть ли для такого descr вендорские смс продукты
  *   </ol>
  * /
  function get_product_descr_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  / **
  * Получение списка IP адресов
  * @param p_names Параметры фильтрации:
  *     <ul>
  *         <li/>show_all, // по умолчанию показываются только активные poi. если надо показать все, то установить значение '1'
  *         <li/>direction,
  *         <li/>car_name,
  *         <li/>poi_ip, // начало строки для фильтрации по IP
  *         <li/>poi_name,
  *         <li/>product_id, // можно несколько через запятую
  *         <li/>product_descr
  *         <li/>auth_fields // через запятую указываются поля ip,tech_prefix,trunk_code,switch
  *         <li/>first_rec
  *         <li/>rec_count
  *         <li/>poi_ids //список идентификаторов poi через запятую
  *     </ul>
  * @return
  *     <ol>
  *         <li/>'voip_poi_id', //POI ID (primary key)
  *         <li/>'voip_poi_gw_ip', //IP address
  *         <li/>'voip_poi_called_pattern', // Called pattern (Tech prefix)
  *         <li/>'voip_poi_full_name', //POI name (virtual field)
  *         <li/>'voip_poi_product_id', //Product ID (link to BAS_PRODUCT table)
  *         <li/>'voip_poi_trunk_code', //Trunk code
  *         <li/>'voip_poi_switch_id', //Switch ID (link to RUT_SOFT_SWITCH table)
  *         <li/>'car_is_active' //Carrier active flag
  *     </ol>
  * /

  function get_voip_poi_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  / **
  * Получение списка IP адресов
  * @param p_names Параметры фильтрации:
  *   <ul>
  *     <li/>direction - 0 клиент, 1 вендор, null - все
  *     <li/>first_rec - пагинация
  *     <li/>rec_count - пагинация
  *     <li/>search_mask - маска поиска IP адреса
  *   </ul>
  * @param p_values
  * @return
  *   <ol>
  *     <li/>voip_poi_gw_ip - ip адрес
  *   </ol>
  * /
  function get_ip_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;
  --
  / **
  * Получение списка форматов даты и времени
  * @param p_names Параметры фильтрации:
  *   <ul>
  *     <li/>type
  *   </ul>
  * @return
  *   <ol>
  *     <li/>datetime_fmt,
  *     <li/>datetime_type
  *   </ol>
  * /
  function get_datetime_fmt_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  function get_timezone_list return sys_refcursor;
  --
  / **
  * Возвращает список (включая деревья) меню в системе, которые доступны пользователю.
  * @return
  *   <ol>
  *     <li/>'p', // menu
  *     <li/>'menu_item_type' // тэг для меню: [general, voice, sms, sms_retail, vua]
  *   </ol>
  * /
  function  get_user_menu_item_list return sys_refcursor;

  procedure update_role(p_role_code varchar2, p_parent_role_code varchar2 := '', p_version_bitmap number := 255, p_do_refresh boolean := true);

  function get_available_roles return prv_varchar256_table_t;

  procedure delete_role(p_role_code varchar2);

  / **
  * Возвращает список ролей в системе с указанием наличия роли у пользователя
  * @return
  *   <ol>
  *     <li/>ROLE_CODE - ID роли (текстовый)
  *     <li/>ROLE_CODE_CAPTION - Название роли
  *     <li/>LEVEL  - уровень этой роли в дереве ролей
  *     <li/>CHECKED - есть ли у пользователя права на эту роль (0-нет, 1-явная роль, 2-роль дана неявно, через родительскую роль)
  *   </ol>
  * /
  function get_role_list return sys_refcursor;

  / **
  * Возвращает список ролей в системе с указанием наличия роли у пользователя
  * @param p_names Параметры
  *   <ul>
  *     <li/>root_role_list,  //Список ролей через запятую, с которых начинать строить деревья ролей
  *   </ul>
  * @param p_values
  * @return
  *   <ol>
  *     <li/>ROLE_CODE - ID роли (текстовый)
  *     <li/>ROLE_CODE_CAPTION - Название роли
  *     <li/>LEVEL  - уровень этой роли в дереве ролей
  *     <li/>CHECKED - есть ли у пользователя права на эту роль (0-нет, 1-явная роль, 2-роль дана неявно, через родительскую роль)
  *   </ol>
  * /
  function get_role_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  / **
  * Возвращает список ролей пользователя
  * @param p_names Параметры:
  *   <ul>
  *     <li/>user_id,
  *     <li/>role_code
  *   </ul>
  * @param p_values
  * @return
  *   <ol>
  *     <li/>'role_code',
  *     <li/>'role_code_caption',
  *     <li/>'level',
  *     <li/>'checked'
  *   </ol>
  * /
  function get_user_role_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  procedure grant_role(p_user_id number, p_role_code varchar2, p_do_implicit_update boolean := true);

  procedure revoke_role(p_user_id number, p_role_code varchar2, p_do_implicit_update boolean := true);

  function has_role(p_role_code varchar2, p_user_id number default null) return number;

  procedure check_role
  (
    p_role_code1  varchar2,
    p_role_code2  varchar2 := null,
    p_role_code3  varchar2 := null,
    p_role_code4  varchar2 := null,
    p_role_code5  varchar2 := null,
    p_user_id     number := null
  );

  procedure set_user_cc(p_user_id number, p_cc_array prv_number_table_t);

  procedure set_user_roles(p_user_id number, p_role_array prv_varchar4000_table_t);
  
  procedure set_parent_users(p_user_id number, p_parent_user_ids prv_number_table_t);

  procedure update_user_roles(p_user_id number:=null);

  procedure fix_dial_code;

  procedure fix_types;

  procedure fix_countries;

  procedure fix_country_code(p_dial_code varchar2 := null);

  / **
  * Импорт файла
  * @param p_names Параметры:
  *   <ul>
  *     <li/>'table_name',
  *     <li/>'filename',
  *     <li/>'separator', // default value ';'
  *     <li/>'skip_cnt', // default value 0
  *     <li/>'clear_before_load' // default value 1
  *   </ul>
  * @param p_values
  * @return
  *   <ol>
  *     <li/>message
  *   </ol> 
  * /
  function import_data_from_file(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return varchar2; --new api

  function import_data_from_file
  (
    p_table_name          varchar2,
    p_filename            varchar2,
    p_separator           char default ';',
    p_skip_cnt            number default 0,
    p_clear_before_load   number default 1
  )
  return varchar2;

  / **
  * Получение списка типов шаблонов
  * @return
  *   <ol>
  *     <li/>template_type_id, // тип шаблона (текстовый идентификатор)
  *     <li/>template_type_name, // имя типа шаблона
  *     <li/>template_format // тип шаблона. Возможные значения: mail, file
  *   </ol>
  * /
  function get_template_type_list return sys_refcursor;

  / **
  * Получение списка шаблонов документов
  * @param p_names Параметры:
  *   <ul>
  *     <li/>'template_type_id', // фильтр по типу
  *     <li/>'template_cc_id', // фильтр по CC
  *     <li/>'template_acc_id', // фильтр по Account ID
  *     <li/>'template_descr', // фильтр по описанию
  *   </ul>
  * @return
  *   <ol>
  *     <li/>'template_id',
  *     <li/>'template_type_id',
  *     <li/>'template_name',
  *     <li/>'template_last_updated',
  *     <li/>'template_acc_ids', // список аккаунтов (id через запятую), для которых работает этот шаблон
  *     <li/>'template_ext_info', // дополнительная текстовая информация шаблона (макс. 4000). В случае шаблоном писем (типы FIN-INVOICE-LETTER, FIN-INVOICE-DET-LETTER, RAT-EXP-LETTER, SMS-RAT-EXP-LETTER), это поле хранит тему письма.
  *     <li/>'template_cc_id', // id юридического лица (contract company)
  *     <li/>'template_content_type', //  тип контента (поддерживаемые типы html,xls,xlsx. Если тип неизвестен то NULL)
  *     <li/>'template_product_type_ids' // список типов продуктов, для которых применим этот шаблон, через запятую
  *     <li/>'template_descr' //  описание темплейта
  *     <li/>'template_product_ids' // список id продуктов, для которых применим этот шаблон, через запятую (параметр применим только для типов шаблонов template_type_id = RAT-EXP, RAT-EXP-LETTER, SMS-RAT-EXP, SMS-RAT-EXP-LETTER)
  *     <li/>'template_is_default'  // темплейт по умолчанию, самый общий шаблон для типа template_type_id. Пользователю недоступно удаление таких темплейтов
  *   </ol>
  * /
  function get_template_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;


  / **
  * Сохранения шаблона в системе. Данная функция позволяет добавлять или изменять загруженные шаблоны.
  * @param p_names Параметры:
  *   <ul>
  *     <li/>'template_id', // Если передано не null, то происходит апдейт соответствюущего шаблона.
  *     <li/>'template_type', // Тип шаблона
  *     <li/>'template_acc_ids', // Список аккаунтов, на которые завязан этот шаблон, через запятую
  *     <li/>'template_ext_info',
  *     <li/>'template_file_name', // имя файла загружаемого шаблона (можно передавать полный path к файлу, все равно база берет символы после точки с конца)
  *     <li/>'template_cc_id', // id юридического лица (contract company)
  *     <li/>'template_product_type_ids' // cписок типов продуктов, для которых применим этот шаблон, через запятую
  *     <li/>'template_product_ids' // cписок id продуктов, для которых применим этот шаблон, через запятую
  *     <li/>'template_descr' //  описание темплейта
  *   </ul>
  * @param p_values
  * @param p_content_blob // Содержимое шаблона
  * /
  procedure update_template(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table, p_content_blob blob);

  / **
  * Удаление шаблона (Default шаблон удалять нельзя)
  * /
  procedure delete_template(p_template_id number);

  / **
  * Получение шаблона из системы
  * @param p_names Параметры:
  *   <ul>
  *     <li/>'template_id',
  *     <li/>'format'
  *   </ul>
  * @param p_values
  * @return blob // содержимое шаблона
  * /
  function get_template_content --new api
  (
    p_names       dbms_sql.varchar2_table,
    p_values      dbms_sql.varchar2_table,
    p_filename    out varchar2
  )
  return blob;

  / **
  * Получение шаблона из системы
  * @param p_template_id
  * @param p_format
  * @param out p_filename
  * @@return blob // содержимое шаблона
  * /
  function get_template_content --old api. ready to delete
  (
    p_template_id   number,
    p_format        varchar2 default 'xls',
    p_filename      out varchar2
  )
  return blob;

  function get_template_blob
  (
    p_template_type           varchar2,
    p_template_acc_id         number,
    p_template_cc_id          number := null,
    p_template_content_type   varchar2 := null,
    p_template_product_type   number default null,
    p_template_product_id     number default null
  )
  return blob;

  function get_template_ext_info
  (
    p_template_type           varchar2,
    p_template_acc_id         number,
    p_template_cc_id          number := null,
    p_template_content_type   varchar2 := null,
    p_template_product_type   number default null,
    p_template_product_id     number default null
  )
  return varchar2;

  function get_template_rec
  (
    p_template_type           varchar2,
    p_template_acc_id         number,
    p_templace_cc_id          number := null,
    p_template_content_type  varchar2 := null,
    p_template_product_type  number default null,
    p_template_product_id    number default null
  )
  return bas_template%rowtype;
  --
  / **
  * region_id, name, manager_user_id
  * /
  function get_region_list return sys_refcursor;

  / **
  * region_id, name, manager_user_id
  * /
  procedure update_region(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);

  procedure delete_region(p_region_id number);
  --
  / **
  * Список банковских счетов
  * @param p_names Параметры фильтрации:
  *     <ul>
  *         <li/>'bacc_id',
  *         <li/>'active_at', // момент времени, на который банковский счёт активен
  *         <li/>'car_id' // кэрриер
  *     </ul>
  * @return
  *     <ol>
  *         <li/>'bacc_id', // id банковского счёта
  *         <li/>'bacc_bank_name', // Наименование банка
  *         <li/>'bacc_recipient_name', // Наименование получателя
  *         <li/>'bacc_cc_id', // Contract company
  *         <li/>'bacc_account', // Номер счета
  *         <li/>'bacc_currency_code', // Валюта(ы) счета (на текущий момент - произвольное текстовое поле)
  *         <li/>'bacc_swift_code', // SWIFT
  *         <li/>'bacc_corr_accounts', // Корреспондентские счета
  *         <li/>'bacc_start_date', // Период активности
  *         <li/>'bacc_end_date',
  *         <li/>'bacc_comments' // Комментарии
  *     </ol>
  * /
  function get_bank_account_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  / **
  * Обновление банковского счета
  * @param p_names Параметры:
  *     <ul>
  *         <li/>'bacc_id', // id банковского счёта
  *         <li/>'bacc_bank_name', // Наименование банка
  *         <li/>'bacc_recipient_name', // Наименование получателя
  *         <li/>'bacc_cc_id', // Contract company
  *         <li/>'bacc_account', // Номер счета
  *         <li/>'bacc_currency_code', // Валюта(ы) счета (на текущий момент - произвольное текстовое поле)
  *         <li/>'bacc_swift_code', // SWIFT
  *         <li/>'bacc_corr_accounts', // Корреспондентские счета
  *         <li/>'bacc_start_date', // Период активности
  *         <li/>'bacc_end_date',
  *         <li/>'bacc_comments' // Комментарии
  *     </ul>
  * /
  procedure update_bank_account(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);

  / **
  * Удаление банковского счета
  * /
  procedure delete_bank_account(p_bacc_id number);
  --
  function get_manager_acc_list(p_acc_id number) return sys_refcursor;

  procedure update_manager_acc(p_man_acc_id number,p_start_date date);
  --
  / **
  * Получение списка единиц измерения
  * @return
  *     <ol>
  *         <li/>'unit_id', - уникальный идентификатор
  *         <li/>'unit_name' - название единицы измерения
  *     </ol>
  * /
  function get_unit_list return sys_refcursor;

  / **
  * Обновление единицы измерения
  * @param p_names Параметры фильтрации:
  *     <ul>
  *         <li/>unit_id,
  *         <li/>unit_name
  *     </ul>
  * /
  procedure update_unit(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);

  procedure delete_unit(p_unit_id number);
  --
  / **
  *
  * @return
  *     <ol>
  *         <li/>'calendar_id', // ID календаря
  *         <li/>'calendar_descr' // Описание
  *     </ol>
  * /
  function get_calendar_list return sys_refcursor;

  / **
  *
  * @param p_names Параметры фильтрации:
  *     <ul>
  *         <li/>calendar_id - ID для апдейта
  *         <li/>calendar_descr - Описание календаря при вставке и апдейте
  *     </ul>
  * /
  procedure update_calendar(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);

  / **
  * Удаление исключения из указанного календаря на указанную дату
  * /
  procedure delete_calendar(p_calendar_id number);

  / **
  *
  * @param p_names Параметры фильтрации:
  *     <ul>
  *         <li/>calendar_id - фильтр по calendar_id
  *         <li/>start_date, end_date - фильтр по периоду
  *     </ul>
  * @return
  *     <ol>
  *         <li/>'dcheck', // дата
  *         <li/>'day_name' // название дня (Выходной или рабочий)
  *     </ol>
  * /
  function get_calendar_content_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  procedure update_calendar_content(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);

  procedure delete_calendar_content(p_calendar_id number, p_dcheck date);

  --classifier
  function get_classifier_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  procedure update_classifier(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);

  procedure delete_classifier(p_classifier_id number);

  function get_classifier_kind_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  function get_classifier_type_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  function get_classifier_class_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  function get_next_id(p_sequence_name varchar2) return number;

  / **
  * Получение списка условия sucharge_condition - deprecated sinse 3.4.21
  * @return
  *   <ol>
  *     <li/>'condition', // Наименование условия
  *   </ol>
  * /
  function get_surcharge_condition_list return sys_refcursor;

  --
  function get_cc_rec(p_cc_id number) return bas_contract_company%rowtype;

  procedure check_rights(p_car_id number, p_entity varchar2, p_entity_id number);

  -- DNIS Refbook

  / **
  * Получение списка DNIS reference.
  * @param p_names Параметры фильтрации, пагинации и сортировки:
  * <ul>
  *   <li/>'id', // id референса. Конкретный - для редактирования, null - для создания.
  *   <li/>'prefix', // Префикс. Максимальная длина 99 символов. Обязательное поле.
  *   <li/>'min_length', // Минимальная длина номера. Допустимые значения: null, 0-99.
  *   <li/>'max_length' // Максимальная длина номера. Допустимые значения: null, 0-99.
  *   <li/>'first_rec',
  *   <li/>'rec_count'
  *   <li/>'orderby_clause // гибкая
  * </ul>
  * @param p_values Значения параметров фильтрации, пагинации и сортировки:
  * @return Курсор со следующии полями:
  * <ol>
  *   <li/>'id', // [*]
  *   <li/>'prefix', // [*]
  *   <li/>'min_length',
  *   <li/>'max_length',
  *   <li/>'total_cnt' // Количество записей (только в первой строке)
  * </ol>
  * /
  function get_dnis_ref_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;
  / **
  * Обновление/создание DNIS reference.
  * @param p_names Параметры редактирования/создания:
  * <ul>
  *   <li/>'id', // id референса. Конкретный - для редактирования, null - для создания.
  *   <li/>'prefix', // Префикс. Максимальная длина 99 символов. Обязательное поле.
  *   <li/>'min_length', // Минимальная длина номера. Допустимые значения: null, 0-99.
  *   <li/>'max_length' // Максимальная длина номера. Допустимые значения: null, 0-99.
  * </ul>
  * @param p_values Значения параметров редактирования/создания
  * /
  procedure update_dnis_ref(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);
  / **
  * Удаление DNIS reference.
  * @param p_dnis_ref_ids Массив id референсов
  * /
  procedure delete_dnis_ref(p_dnis_ref_ids dbms_sql.number_table);
  --

  / **
  * Получение списка изменений таблицы кодов
  * @param p_names Параметры фильтрации, пагинации и сортировки:
  * <ul>
  *   <li/>'p_record_id'
  * </ul>
  * @param p_values Значения параметров редактирования/создания
  * @return Курсор со следующии полями:
  * <ol>
  *   <li/>'record_id', // [*]
  *   <li/>'dial_code', // [*]
  *   <li/>'effective_date', // [*]
  *   <li/>'new_dial_code_country', // [*]
  *   <li/>'new_dial_code_region', // [*]
  *   <li/>'new_dial_code_type' // [*]
  *   <li/>'last_error' // текст ошибки обновления диалкода (если обновление завершилось с ошибкой). Записи с непустой ошибкой исключаются из будущего рассмотрения. Ошибка сбрасывается при любом апдейте.
  * </ol>
  * /
  function get_dc_pending_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;

  / **
  * Обновление/создание списка изменений таблицы кодов.
  * @param p_names Параметры редактирования/создания:
  * <ul>
  *   <li/>'record_id', //
  *   <li/>'dial_code', //
  *   <li/>'effective_date', //
  *   <li/>'new_dial_code_country', //
  *   <li/>'new_dial_code_region', //
  *   <li/>'new_dial_code_type' //
  * </ul>
  * @param p_values Значения параметров редактирования/создания
  * /
  procedure update_dc_pending(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);

  / **
  * Удаление записи из таблицы изменений кодов
  * @param p_record_id
  * /
  procedure delete_dc_pending(p_record_id number);
  procedure apply_pending_dc;
  --
  / **
  * Получение списка почтовых нотификаций.
  * @param p_names Параметры фильтрации, пагинации и сортировки:
  * <ul>
  *   <li/>'id', // id нотификации
  *   <li/>'type', // тип нотификации. Обязательное поле. В настоящее время поддержаны следующие:
  *   <ul>
  *     <li/>//Technical
  *     <li/>//Account alert
  *     <li/>//Rate change notification
  *     <li/>//Invoice email
  *   </ul>
  *   <li/>'time1', // Нижняя граница диапазона запуска
  *   <li/>'time2', // Верхняя граница диапазона запуска
  *   <li/>'subject', // Тема письма.
  *   <li/>'text', // Текст письма. Используется только для фильтрации и только как plaintext маска, т.е. если, например, текст письма - в HTML, то можно передавать фильтр вида *div*, хотя сам этот тег при отображении тела письма будет не виден.
  *   <li/>'status', // Статус нотификации. Числовое поле:
  * <ul>
  *   <li/>//1 - scheduled
  *   <li/>//2 - successful
  *   <li/>//3 - failed
  *   <li/>//4 - expired
  * </ul>
  *   <li/>'cc_id', // contract company id
  *   <li/>'first_rec',
  *   <li/>'rec_count'
  *   <li/>'orderby_clause
  * </ul>
  * @param p_values Значения параметров фильтрации, пагинации и сортировки:
  * @return Курсор со следующии полями:
  * <ol>
  *   <li/>'id', // id нотификации. Не отображается в интерфейсе, не используется в сортировке.
  *   <li/>'type', // [*] Тип нотификации.
  *   <li/>'time', // [*] Назначенное время запуска нотификации.
  *   <li/>'status', // [*] Статус нотификации.
  *   <li/>'subject', // [*] Тема письма.
  *   <li/>'text', // Текст письма. Всегда NULL, начиная с 3.4.36. В случае пожелания устранить это поле прошу обратиться. Для получения актуальных текстов писем нужно использовать метод bas_utils.get_mail_notification_text.
  *   <li/>'doc_id', // id документа - вложения
  *   <li/>'doc_filename', // короткое (без пути) исходное имя файла вложения
  *   <li/>'cc_id', // contract company id
  *   <li/>'total_cnt' // Количество записей
  * </ol>
  * /
  function get_mail_notification_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;
  / **
  * Получение текста письма оповещения.
  * @param p_names Параметры фильтрации:
  * <ul>
  *   <li/>'id' // id нотификации
  * </ul>
  * @param p_values Значения параметров фильтрации:
  * @return BLOB тела письма
  * /
  function get_mail_notification_text(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return blob;
  / **
  * @deprecated
  * Обновление/создание почтовых нотификаций.
  * @param p_names Параметры редактирования/создания:
  * <ul>
  *   <li/>'id', // id нотификации (для редактирования), null для создания
  *   <li/>'type', // тип нотификации. В настоящее время поддержаны следующие: "Technical". Передаётся текстом, как есть. Обязательное поле.
  *   <li/>'time', // Время, на которое назначена нотификация. Если время - будущее, то статус нотификации меняется на scheduled. Если сильно в прошлое (определяется системным параметром, то статус меняется на expired). Обязательное поле.
  *   <li/>'subject', // Тема письма. Обязательное поле.
  *   <li/>'text' // Текст письма (плейнтекст максимум 2000 символов). Обязательное поле.
  *   <li/>'doc_id', // id документа - вложения
  *   <li/>'real_file_name', // полное реальное имя файла, которое нужно загрузить в качестве вложиния
  *   <li/>'file_name' // короткое (без пути) исходное имя файла вложения.
  * </ul>
  * @param p_values Значения параметров редактирования/создания
  * Логика работы параметров doc_id, real_file_name и file_name:<br/>
  * <ol>
  *   <li/>Передан doc_id == null, real_file_name и file_name пустые - если для нотификации есть документ, он удаляется; если нет - ничего не происходит
  *   <li/>Передан doc_id == null, real_file_name и file_name не пустые - документ создаётся, его id кладётся в поле записи
  *   <li/>Передан doc_id != null, real_file_name и file_name пустые - ничего не происходит
  *   <li/>Передан doc_id != null, real_file_name и file_name не пустые - загружается новый документ под старым id; id не меняется
  *   <li/>Если в результате операции создаётся новый документ, то старый удаляется.
  * </ol>
  * Примечание: при сохранении документа имя файла может быть преобразовано из предложенного в параметре варианта в приемлемый для базы. Целесообразно после изменения данных, включаюищх загрузку документа, перечитать текущую строку.
  * /
  procedure update_mail_notification(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);
  / **
  * Обновление/создание почтовых нотификаций.
  * @param p_names Параметры редактирования/создания:
  * <ul>
  *   <li/>'id', // id нотификации (для редактирования), null для создания
  *   <li/>'type', // тип нотификации. Обязательное поле. В настоящее время поддержаны следующие:
  *   <ul>
  *     <li/>//Technical
  *     <li/>//Account alert
  *     <li/>//Rate change notification
  *     <li/>//Invoice email
  *   </ul>
  *   <li/>'time', // Время, на которое назначена нотификация. Если время - будущее, то статус нотификации меняется на scheduled. Если сильно в прошлое (определяется системным параметром, то статус меняется на expired). Обязательное поле.
  *   <li/>'subject', // Тема письма. Обязательное поле.
  *   <li/>'doc_id', // id документа - вложения
  *   <li/>'real_file_name', // полное реальное имя файла, которое нужно загрузить в качестве вложиния
  *   <li/>'file_name', // короткое (без пути) исходное имя файла вложения.
  *   <li/>'cc_id' // contract company ID
  * </ul>
  * @param p_values Значения параметров редактирования/создания
  * @param p_text Текст письма (HTML или plaintext). Обязательное поле.
  * Логика работы параметров doc_id, real_file_name и file_name:<br/>
  * <ol>
  *   <li/>Передан doc_id == null, real_file_name и file_name пустые - если для нотификации есть документ, он удаляется; если нет - ничего не происходит
  *   <li/>Передан doc_id == null, real_file_name и file_name не пустые - документ создаётся, его id кладётся в поле записи
  *   <li/>Передан doc_id != null, real_file_name и file_name пустые - ничего не происходит
  *   <li/>Передан doc_id != null, real_file_name и file_name не пустые - загружается новый документ под старым id; id не меняется
  *   <li/>Если в результате операции создаётся новый документ, то старый удаляется.
  * </ol>
  * Примечание: при сохранении документа имя файла может быть преобразовано из предложенного в параметре варианта в приемлемый для базы. Целесообразно после изменения данных, включаюищх загрузку документа, перечитать текущую строку.
  * /
  procedure update_mail_notification(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table, p_text blob);
  / **
  * Удаление почтовых нотификаций.
  * @param p_notification_ids Массив id удаляемых нотификаций
  * /
  procedure delete_mail_notification(p_notification_ids dbms_sql.number_table);
  procedure send_notifications;

  / **
  * Обертка для dbms_lock.sleep под новый api
  * @param p_seconds // Количество секунд для sleep
  * /
  procedure sleep(p_seconds number);
  
  / **
  * Процедура отправки информации с обратной связью об интерфейсах системы.
  * @param p_names Имена параметров
  * <ul>
  *   <li/>'subject', // Тема письма
  *   <li/>'file_name' // Имя файла (вложения). Если передан, то это имя файла из каталога DEFAULT_DIR (по умолчанию - /u01/app/oracle/invoice.files)
  * <ul>
  * @param p_values Значения параметров
  * @param p_body Тело письма (HTML). Обязательный параметр.
  * /
  procedure send_feedback(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table, p_body blob);
  ----------------------------------------------------------------------------------------------------------------------

  / **
  * Получение справочника регулярных выражений
  * @param p_names Параметры:
  *     <ul>
  *         <li/>'id', // id записи
  *         <li/>'name', // имя записи
  *         <li/>'pattern', // значение регулярного выражения
  *         <li/>'descr' // описание регулярного выражения
  *         <li/>'orderby_clause' // параметр сортировки (гибкая)
  *     </ul>
  * @return
  *     <ol>
  *         <li/>'id', //[*]
  *         <li/>'name', //[*]
  *         <li/>'pattern', //[*]
  *         <li/>'descr' //[*]
  *         <li/>'total_cnt'
  *     </ol>
  * /
  function get_regexp_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor;
  / **
  * Создание/изменение записи в справочнике регулярных выражений
  * @param p_names Параметры:
  *     <ul>
  *         <li/>'id', // id записи
  *         <li/>'name', // имя записи
  *         <li/>'pattern', // значение регулярного выражения
  *         <li/>'descr' // описание регулярного выражения
  *     </ul>
  * /
  procedure update_regexp(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table);
  / **
  * Удаление регулярного выражения из справочника
  * @param p_id id регулярного выражения
  * /
  procedure delete_regexp(p_id number);*/
  ----------------------------------------------------------------------------------------------------------------------
end;
/
create or replace package body app_utils is
  -----------------------------------------------------------------------------------------------
  procedure set_context_var(p_parameter in varchar2,p_value in varchar2) is
  begin
    if p_parameter is not null then
      dbms_session.set_context('user_ctx', p_parameter, p_value);
    end if;
  end;
  -----------------------------------------------------------------------------------------------
  procedure clear_user_env is
  begin
  
    --Clear all user context vars
    dbms_session.clear_all_context('user_ctx');

  end;
  -----------------------------------------------------------------------------------------------
  function get_user_id return varchar2 is
  begin
    return sys_context('user_ctx', 'user_id');
  end;
  -----------------------------------------------------------------------------------------------
  function get_user_name return varchar2 is
  begin
    return sys_context('user_ctx', 'user_name');
  end;
  -----------------------------------------------------------------------------------------------
  procedure init_user_env(p_user_rec app_users%rowtype, p_ip varchar2) is
  begin

    clear_user_env;

    --Set user vars
    set_context_var('user_name', p_user_rec.user_email);
    set_context_var('user_id', p_user_rec.user_id);

  end;
  -----------------------------------------------------------------------------------------------
  --Local trusted authorization
  procedure init_user_env(p_user_id app_users.user_id%type) is
    l_user_rec app_users%rowtype;
  begin

    select *
    into l_user_rec
    from app_users
    where user_id = p_user_id;

    init_user_env(l_user_rec, '127.0.0.1');

  end;
  -----------------------------------------------------------------------------------------------


/*  --
  function c_notif_scheduled     return number is begin return 1; end;
  function c_notif_successful    return number is begin return 2; end;
  function c_notif_failed        return number is begin return 3; end;
  function c_notif_expired       return number is begin return 4; end;
  --
  function c_notif_expiry_period return number is begin return nvl(prv_utils.get_param('PARAM-NOTIFICATION_EXPIRY'), 3); end;
  ----------------------------------------------------------------------------------------------------
  function c_mixed_group_flag             return varchar2 is begin return '{..}'; end;
  function c_email_contact_code           return varchar2 is begin return 'CNT-EMAIL'; end;
  function c_max_date                     return date is begin return to_date('1.1.2100', 'DD.MM.YYYY'); end;
  function c_file_directory               return varchar2 is begin return 'DEFAULT_DIR'; end;
  --
  function c_invoice_template_type        return varchar2 is begin return 'FIN-INVOICE'; end;
  function c_credit_note_template_type    return varchar2 is begin return 'FIN-CREDIT-NOTE'; end;
  function c_inv_det_template_type        return varchar2 is begin return 'FIN-INVOICE-DETAILS'; end;
  function c_cr_note_det_template_type    return varchar2 is begin return 'FIN-CREDIT-NOTE-DETAILS'; end;
  function c_rat_exp_template_type        return varchar2 is begin return 'RAT-EXP'; end;
  function c_rat_rcn_template_type        return varchar2 is begin return 'RAT-RCN'; end;
  function c_rat_rcn_letter               return varchar2 is begin return 'RAT-RCN-LETTER'; end;
  function c_rat_ana_exp_template_type    return varchar2 is begin return 'RAT-ANA-EXPORT'; end;
  function c_invoice_letter               return varchar2 is begin return 'FIN-INVOICE-LETTER'; end;
  function c_invoice_det_letter           return varchar2 is begin return 'FIN-INVOICE-DET-LETTER'; end;
  function c_credit_note_letter           return varchar2 is begin return 'FIN-CREDIT-NOTE-LETTER'; end;
  function c_rate_exp_letter              return varchar2 is begin return 'RAT-EXP-LETTER'; end;
  function c_sms_rate_exp_template_type   return varchar2 is begin return 'SMS-RAT-EXP'; end;
  function c_sms_rate_exp_letter          return varchar2 is begin return 'SMS-RAT-EXP-LETTER'; end;
  function c_credit_usage_template        return varchar2 is begin return 'FIN-CREDIT-ALERT-LETTER'; end;
  function c_balance_alert_template       return varchar2 is begin return 'FIN-BALANCE-ALERT-LETTER'; end;
  function c_fin_deffered_pay_letter      return varchar2 is begin return 'FIN-DEFFERED_PAY_LETTER'; end;
  function c_sta_cdr_export_letter        return varchar2 is begin return 'STA-CDR-EXPORT-LETTER'; end;
  function c_sta_rerate_letter            return varchar2 is begin return 'STA-RERATE-LETTER'; end;
  function c_trd_blend_route_change       return varchar2 is begin return 'TRD-BLEND-ROUTE-CHANGE-LETTER'; end;
  function c_trd_blend_not_active_letter  return varchar2 is begin return 'TRD-BLEND-NOT-ACTIVE-LETTER'; end;
  function c_clp_new_carrier_letter       return varchar2 is begin return 'CLP-NEW-CARRIER-LETTER'; end;
  function c_clp_new_payment_letter       return varchar2 is begin return 'CLP-NEW-PAYMENT-LETTER'; end;
  function c_clp_failed_payment_letter    return varchar2 is begin return 'CLP-FAILED-PAYMENT-LETTER'; end;
  function c_clp_reverse_payment_letter   return varchar2 is begin return 'CLP-REVERSE-PAYMENT-LETTER'; end;
  function c_sms_edr_export_letter        return varchar2 is begin return 'SMS-EDR-EXPORT-LETTER'; end;
  --
  function c_fin_pay_in_letter            return varchar2 is begin return 'FIN-PAY_IN_NOTIFICATION'; end;
  function c_fin_pay_out_letter           return varchar2 is begin return 'FIN-PAY_OUT_NOTIFICATION'; end;
  --
  function c_clp_activate_letter          return varchar2 is begin return 'CLP-ACTIVATE-LETTER'; end;
  function c_clp_register_letter          return varchar2 is begin return 'CLP-REGISTER-LETTER'; end;
  function c_clp_cdr_exp_letter           return varchar2 is begin return 'CLP_CDR_EXP_LETTER'; end;
  function c_clp_edr_exp_letter           return varchar2 is begin return 'CLP_EDR_EXP_LETTER'; end;
  --User security for portal users
  function c_clp_user_reset_pwd_letter    return varchar2 is begin return 'CLP-RESET-PWD-LETTER'; end;
  function c_clp_user_update_pwd_letter   return varchar2 is begin return 'CLP-USER-UPDATE-PWD-LETTER'; end;
  function c_clp_user_error_pwd_letter    return varchar2 is begin return 'CLP-USER-ERROR-PWD-LETTER'; end;
  --User security for system owner users
  function c_bas_user_reset_pwd_letter    return varchar2 is begin return 'BAS-USER-RESET-PWD-LETTER'; end;
  function c_bas_user_expire_pwd_letter   return varchar2 is begin return 'BAS-USER-EXPIRE-PWD-LETTER'; end;
  function c_bas_user_update_pwd_letter   return varchar2 is begin return 'BAS-USER-CHANGE-PWD-LETTER'; end;
  function c_bas_user_error_pwd_letter    return varchar2 is begin return 'BAS-USER-ERROR-PWD-LETTER'; end;
  --
  function c_clp_campaign_start           return varchar2 is begin return 'CLP-CAMPAIGN-START-LETTER'; end;
  --
  function c_rut_lim_letter               return varchar2 is begin return 'RUT-LIM-LETTER'; end;
  --
  function c_ntf_type_tech                return varchar2 is begin return 'Technical'; end;
  function c_ntf_type_acc                 return varchar2 is begin return 'Account alert'; end;
  function c_ntf_type_rate                return varchar2 is begin return 'Rate change notification'; end;
  function c_ntf_type_inv                 return varchar2 is begin return 'Invoice email'; end;
  --
  function c_sep       return char is begin return ':'; end;
  function c_dir_name  return varchar2 is begin return '/var/www/html/invoice/inbox/rate-import'; end;
  --
  --of kind template type
  function c_tmpl_type_file      return bas_template_type.template_format%type is begin return 'file'; end;
  function c_tmpl_type_mail      return bas_template_type.template_format%type is begin return 'mail'; end;
  --
  function c_tmpl_hand_embed_poi return bas_template.template_handler%type is begin return 'embedded_apach_poi'; end;
  function c_tmpl_hand_docproc   return bas_template.template_handler%type is begin return 'docprocessor'; end;
  function c_tmpl_cont_xls       return bas_template.template_content_type%type is begin return 'xls'; end;
  function c_tmpl_cont_xlsx      return bas_template.template_content_type%type is begin return 'xlsx'; end;
  function c_tmpl_cont_mail      return bas_template.template_content_type%type is begin return 'html'; end;
  --
  --Predefined oracle users
  function c_uidisp_un     return varchar2 is begin return 'INVOICE_UIDISP'; end;
  function c_hwdisp_un     return varchar2 is begin return 'INVOICE_HWDISP'; end;
  function c_api_un        return varchar2 is begin return 'INVOICE_API'; end;
  --
  function c_fs_no_import     return number is begin return 0; end;
  function c_fs_imported      return number is begin return 1; end;
  function c_fs_checked       return number is begin return 2; end;
  function c_fs_ignore        return number is begin return 3; end;
  function c_fs_rollback      return number is begin return 4; end;
  function c_fs_ready2import  return number is begin return 5; end;
  function c_fs_in_progress   return number is begin return 6; end;
  function c_fs_failed        return number is begin return 7; end;
  --
  function c_auto_import_task_type_id   return number is begin return 22; end;
  -----------------------------------------------------------------------------------------------
  function get_user_timezone return number is
  begin
    return nvl(sys_context('user_ctx', 'user_time_offset'),0);
  end;
  -----------------------------------------------------------------------------------------------
  function get_extented_user_info return varchar2 is
  begin
    return sys_context('user_ctx', 'user_full_name')
      || ' (user ID:' || sys_context('user_ctx', 'user_id')||'; '
      || 'login name: ' || sys_context('user_ctx', 'user_name')||'; '
      || 'IP: ' || sys_context('user_ctx', 'user_ip')||')';
  end;
  -----------------------------------------------------------------------------------------------
  procedure trace_login(p_user_name varchar2, p_ip varchar2, p_action varchar2)
  is
    pragma autonomous_transaction;
  begin

    begin
      insert into log_prv_session
      (
        log_id,
        log_time,
        log_action,
        session_id,
        session_code,
        session_db_user,
        session_user,
        session_terminal,
        session_os_user,
        session_host,
        session_ip,
        session_start_time,
        exec_id
      )
      values
      (
        prv_log_id_seq.nextval,
        sysdate,
        p_action,
        sys_context('userenv', 'sessionid'),
        null,
        user,
        p_user_name,
        sys_context('USERENV', 'TERMINAL'),
        sys_context('USERENV', 'OS_USER'),
        sys_context('USERENV', 'HOST'),
        p_ip,
        sysdate,
        prv_var.m_exec_id
      );

      commit;

    exception

      when others then
        if sqlcode = -16000 then
          null;
        else
          raise;
        end if;

    end;

  end;
  -----------------------------------------------------------------------------------------------
  procedure set_product_list(p_user_id  bas_user.user_id%type) is
    l_all_product  number(1);
  begin
    delete from bas_available_product_tmp;

    if bas_utils.has_role('ROLE-ROUTING-EDIT-OWN-PRODUCTS-ONLY', p_user_id) = 1 then
      if bas_utils.has_role('ROLE-ROOT', p_user_id) = 1 then
        l_all_product := 1;
        set_context_var('user_own_product_list', 'all');
      else
        l_all_product := 0;
        set_context_var('user_own_product_list', 'list');
      end if;
    else
      l_all_product := 1;
      set_context_var('user_own_product_list', 'all');
    end if;

    insert into bas_available_product_tmp (product_id, direction)
    select bp.product_id, bp.product_direction direction
    from bas_account ba, bas_product bp
    where ba.acc_id = bp.product_acc_id
    and (l_all_product = 1 or bas_car_utils.get_acc_manager_id(ba.acc_id) = p_user_id);
  end;
  -----------------------------------------------------------------------------------------------
  procedure enable_disable_vpd(p_action varchar2) is
  begin
    if p_action = 'enable' then
      set_context_var('show_temporary', null);
    elsif p_action = 'disable' then
      set_context_var('show_temporary', 1);
    else
      raise_application_error(-20000, prv_utils.get_message('BAS-ERR-UNKNOWN-ACTION', p_action));
    end if;
  end;
  -----------------------------------------------------------------------------------------------
  function login(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return varchar2
  is
    pragma autonomous_transaction;
    --
    l_param   prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'user_name,password,ip,lang');
    v_sid     varchar2(256);
  begin

    bas_utils.login(l_param('user_name'), l_param('password'), v_sid, l_param('ip'), l_param('lang'));

    return v_sid;

  end;
  -----------------------------------------------------------------------------------------------
  procedure login(p_user_name varchar2, p_password varchar2, p_sid out varchar2, p_ip varchar2, p_lang varchar2 := null)
  is
    pragma autonomous_transaction;
    --
    l_user_rec        bas_user%rowtype;
    l_mock_user_rec   bas_user%rowtype;
    l_ip              varchar2(256) := nvl(p_ip, sys_context('USERENV', 'IP_ADDRESS'));
    l_allowed_ips     dbms_sql.varchar2_table;
    l_ip_check        boolean := false;
    l_create_date     date;
    l_fail_auth_count number;
    l_real_name       varchar2(256);
    l_mock_name       varchar2(256);
    l_lang            bas_user.user_lang%type;
    --
    function get_user_rec(p_user_name varchar2) return bas_user%rowtype
    is
      l_res bas_user%rowtype;
    begin

      select *
      into l_res
      from bas_user
      where user_name = p_user_name
        and user_active = 1
        and user_car_id = 1;

      return l_res;

    exception
      when no_data_found then
        return null;

    end;
    --
    procedure set_failed_auth_attempt(p_new_val number)
    is
    begin

      prv_var.m_skip_event_sending := 1;
      enable_disable_vpd('disable');
      
      update bas_user set user_failed_auth_attempt = p_new_val where user_id = l_user_rec.user_id;

      commit;

      enable_disable_vpd('enable');
      prv_var.m_skip_event_sending := null;

    end;
    --
    procedure set_left_auth(p_new_val number)
    is
    begin

      prv_var.m_skip_event_sending := 1;
      enable_disable_vpd('disable');

      update bas_user set user_left_auth = p_new_val where user_id = l_user_rec.user_id;

      commit;

      enable_disable_vpd('enable');
      prv_var.m_skip_event_sending := null;

    end;
    --
    procedure set_last_auth_attempt(p_new_val date)
    is
    begin

      prv_var.m_skip_event_sending := 1;
      enable_disable_vpd('disable');

      update bas_user set user_last_auth_attempt = p_new_val where user_id = l_user_rec.user_id;

      commit;

      enable_disable_vpd('enable');
      prv_var.m_skip_event_sending := null;

    end;
    --
  begin

    if sys_context('user_ctx', 'user_name') is not null then
      logout;
    end if;

    select
      regexp_substr(p_user_name, '[^#]+', 1, 1),
      regexp_substr(p_user_name, '[^#]+', 1, 2)
    into l_real_name, l_mock_name
    from dual;

    begin
      bas_utils.enable_disable_vpd('disable');
      l_user_rec := get_user_rec(l_real_name);
      l_mock_user_rec := get_user_rec(nvl(l_mock_name, l_real_name));
      l_lang := nvl(p_lang, l_user_rec.user_lang);
      bas_utils.enable_disable_vpd('enable');
    exception
      when others then
        bas_utils.enable_disable_vpd('enable');
        raise;
    end;

    if l_user_rec.user_id is null
      or (p_user_name like '_%#_%' and (l_mock_user_rec.user_id is null or has_role('ROLE-IMPERSONATE', l_user_rec.user_id) = 0))
    then
      raise_application_error
      (
        -20000,
        prv_utils.get_message(p_message_code=> 'ERR-WRONG-PASSWORD', p_user_lang => l_lang), false
      );
    end if;

    if has_role('ROLE-IMPERSONATE', l_user_rec.user_id) = 0 then
      l_mock_user_rec := l_user_rec;
    end if;

    l_fail_auth_count := nvl(l_user_rec.user_failed_auth_attempt, 0);
    if l_user_rec.user_last_auth_attempt < sysdate -- #22982
      and (sysdate - l_user_rec.user_last_auth_attempt) * 86400 < l_fail_auth_count
    then
      dbms_lock.sleep(least(l_fail_auth_count, 5));
      raise_application_error
      (
        -20000,
        prv_utils.get_message
        (
          p_message_code => 'ERR-AUTH-COOL-DOWN',
          p_param1 => greatest(round(((l_user_rec.user_last_auth_attempt + l_fail_auth_count * 86400) - sysdate) / 86400), 1),
          p_user_lang => l_lang
        ),
        false
      );
    end if;

    set_last_auth_attempt(sysdate);

    if l_user_rec.user_password != prv_utils.md5(l_real_name || p_password || l_user_rec.user_salt) then

      l_fail_auth_count := nvl(l_user_rec.user_failed_auth_attempt, 0) + 1;
      set_failed_auth_attempt(l_fail_auth_count);

      dbms_lock.sleep(least(l_fail_auth_count, 5));

      raise_application_error
      (
        -20000,
        prv_utils.get_message(p_message_code => 'ERR-WRONG-PASSWORD', p_user_lang => l_lang),
        false
      );

    end if;

    if l_user_rec.user_expire_date < sysdate then

      if l_user_rec.user_left_auth <= 0 then

        set_failed_auth_attempt(nvl(l_user_rec.user_failed_auth_attempt, 0) + 1);

        raise_application_error
        (
          -20000,
          prv_utils.get_message(p_message_code => 'ERR-ACCOUNT-EXPIRED', p_user_lang => l_lang),
          false
        );

      else

        set_left_auth(l_user_rec.user_left_auth - 1);

      end if;

    end if;

    --IP address check
    if l_user_rec.user_allowed_ip is not null then

      l_allowed_ips := prv_utils.str2plsqltable(l_user_rec.user_allowed_ip, ',');

      for i in l_allowed_ips.first .. l_allowed_ips.last
      loop
        if
          prv_utils.overlap
          (
            p_ip,
            32,
            trim(prv_utils.get_field_val(l_allowed_ips(i), 1, '/')),
            trim(nvl(prv_utils.get_field_val(l_allowed_ips(i), 2, '/'), 32))
          ) = 1
        then
          l_ip_check := true;
          exit;
        end if;

      end loop;

      if not l_ip_check then

        set_failed_auth_attempt(nvl(l_user_rec.user_failed_auth_attempt, 0) + 1);
        raise_application_error
        (
          -20000,
          prv_utils.get_message(p_message_code => 'ERR-IP-NOT-ALLOWED', p_param1 => p_ip, p_user_lang => l_lang),
          false
        );

      end if;

    end if;

    --Set user environment
    init_user_env(l_mock_user_rec, p_ip);

    dbms_application_info.set_module
    (
      case
        when user = c_uidisp_un then'inVoice (' || p_user_name || ')'
        when user = c_hwdisp_un then 'HW dispatcher (' || l_ip || ')'
        when user = c_api_un then 'External API (' || l_ip || ')'
      end,
      null
    );
    dbms_application_info.set_client_info(l_ip);

    set_failed_auth_attempt(0);

    p_sid := prv_utils.get_random_string(32);

    commit;

    set_user_lang(l_lang);

    trace_login(p_user_name, p_ip, 'i');

  exception
    when others then
      trace_login(p_user_name, p_ip, 'a');
      bas_utils.enable_disable_vpd('enable');
      raise;

  end;
  -----------------------------------------------------------------------------------------------
  procedure logout
  is
  begin

    set_context_var('user_name', null);
    set_context_var('user_id', null);

    update log_prv_session
    set session_end_time = sysdate
    where session_id = sys_context('userenv', 'sessionid');

    commit;

  end;
  -----------------------------------------------------------------------------------------------
  procedure check_auth is
  begin
    if sys_context('user_ctx', 'user_name') is null then
      if user = 'INVOICE' then
        set_context_var('user_name', user);
      else
        raise_application_error(-20000, prv_utils.get_message('ERR-NO-AUTH'),false);
      end if;
    end if;

    if to_date(prv_utils.get_context_var(prv_utils.c_session_expire_ctx), prv_var.c_sys_datetime_fmt) < sysdate then
      raise_application_error(-20000, prv_utils.get_message('ERR-DEMO_SESSION_EXPIRED'));
    end if;

  end;
  -----------------------------------------------------------------------------------------------
  function get_cc_id(p_car_id bas_carrier.car_id%type) return number
  is
    l_cc_id bas_contract_company.cc_id%type;
  begin
    select car_cc_id
    into l_cc_id
    from bas_carrier
    where car_id = p_car_id;
    return l_cc_id;
    exception when no_data_found then
      return null;
  end;
  ----------------------------------------------------------------------------------
  function get_user_email(p_user_id bas_user.user_id%type) return varchar2
  is
    l_email bas_user_info.info_value%type;
  begin
    select info_value
    into l_email
    from bas_user_info
    where info_user_id = p_user_id
    and info_type_code = 'CNT-EMAIL';
    return l_email;
    exception when no_data_found then
      raise_application_error(-20000, prv_utils.get_message('ERR-USER_WITHOUT_EMAIL', p_user_id));
  end;
  ----------------------------------------------------------------------------------
  function find_user_rec(p_name_or_email varchar2) return bas_user%rowtype
  is
    l_user_id bas_user.user_id%type;
  begin
    select coalesce
    (
      (
        select u.user_id
        from bas_user u
        where u.user_name = p_name_or_email
      ),
      (
        select i.info_user_id
        from bas_user_info i
        where info_value = p_name_or_email
        and info_type_code = 'CNT-EMAIL'
        and i.info_user_id in (select u.user_id from bas_user u where u.user_active = 1)
      )
    )
    into l_user_id
    from dual;
  
    if l_user_id is null then
      raise_application_error(-20000, prv_utils.get_message('ERR-USER_WITH_SUCH_EMAIL_OR_NAME_NOT_FOUND', p_name_or_email));
    end if;
  
    return bas_car_utils.get_user_rec(l_user_id);
  
    exception when others then
      if sqlcode = -01427 then
        raise_application_error(-20000, prv_utils.get_message('ERR-MORE_THAN_ONE_USER_WITH_SUCH_EMAIL', p_name_or_email));
      else
        raise;
      end if;
  end;
  ----------------------------------------------------------------------------------
  function is_partner_portal_user(p_user_id bas_user.user_id%type) return boolean
  is
  begin
    return bas_utils.has_role('ROLE_WHOLESALE', p_user_id) = 1;
  end;
  ----------------------------------------------------------------------------------
  function is_selfcare_user(p_user_id bas_user.user_id%type) return boolean
  is
  begin
    return bas_utils.has_role('ROLE_SMS_RETAIL', p_user_id) = 1;
  end;
  ----------------------------------------------------------------------------------
  function get_interface_names(l_user_rec bas_user%rowtype, l_cc_rec bas_contract_company%rowtype) return varchar2
  is
    c_def_administration_name   bas_contract_company.cc_administration_name%type := 'Administration interface';
    c_def_selfcare_name         bas_contract_company.cc_selfcare_name%type := 'webCenter';
    c_def_partner_portal        bas_contract_company.cc_partner_portal_name%type := 'Client portal';
  begin

    if l_user_rec.user_car_id = 1 then

      return nvl(l_cc_rec.cc_administration_name, c_def_administration_name);

    else

      return case when is_selfcare_user(l_user_rec.user_id) then nvl(l_cc_rec.cc_selfcare_name, c_def_selfcare_name) end
        || case when is_selfcare_user(l_user_rec.user_id) and is_partner_portal_user(l_user_rec.user_id) then ', ' end
        || case when is_partner_portal_user(l_user_rec.user_id) then nvl(l_cc_rec.cc_partner_portal_name, c_def_partner_portal) end;  

    end if;

  end;
  ----------------------------------------------------------------------------------
  procedure request_password_reset(p_name_or_email varchar2, p_link varchar2)
  is
    l_activation_key      bas_reset_pwd.activation_key%type := prv_utils.get_random_string(64);
    l_user_rec            bas_user%rowtype := find_user_rec(p_name_or_email);
    l_cc_id               bas_carrier.car_cc_id%type := get_cc_id(l_user_rec.user_car_id);
    l_cc_rec              bas_contract_company%rowtype := get_cc_rec(l_cc_id);
    l_email               bas_user_info.info_value%type := get_user_email(l_user_rec.user_id);
    l_values              prv_exp_utils.values_t;
    l_letter_template_id  bas_template.template_type_id%type;
    l_link                varchar2(4000);
    l_mail_acc    prv_mail_server.mail_server_type_id%type := case
        when l_user_rec.user_car_id = 1 then
          prv_mail_utils.c_default_mail_server
        else
          prv_mail_utils.c_clp_mail_server
      end;
  begin

    if l_user_rec.user_active != 1 then
      raise_application_error(-20000, prv_utils.get_message('ERR-USER_NOT_ACTIVE'));
    end if;
    
    
    if l_user_rec.user_car_id = 1 then

      l_letter_template_id := bas_utils.c_bas_user_reset_pwd_letter;
      l_link := coalesce(p_link, prv_utils.get_param('PARAM-APP-URL'));
      
      --System owner user
      l_values('UILink')(1) := prv_utils.get_param('PARAM-APP-URL');
      l_values('PortalLink')(1) := null;
      l_values('SelfcareLink')(1) := null;
        
    else

      l_letter_template_id := case l_user_rec.user_active
          when 0
          then bas_utils.c_clp_activate_letter
          else bas_utils.c_clp_user_reset_pwd_letter
        end;

      --Partner user
      l_values('UILink')(1) := null;
      l_values('PortalLink')(1) := case 
        when is_partner_portal_user(l_user_rec.user_id) then 
          nvl(l_cc_rec.cc_partner_url, prv_utils.get_param('CLP-URL'))
        end;
      l_values('SelfcareLink')(1) := case 
        when is_selfcare_user(l_user_rec.user_id) then 
          nvl(l_cc_rec.cc_selfcare_url, prv_utils.get_param('CLP-SELFCARE_URL'))
        end;
        
      l_link := coalesce
      (
        p_link,
        l_values('SelfcareLink')(1),
        l_values('PortalLink')(1)
      );        
              
    end if;
      
    merge into bas_reset_pwd
    using dual
    on (user_id = l_user_rec.user_id)
    when matched
    then update set activation_key = l_activation_key, link = l_link
    when not matched then insert (user_id, activation_key, link)
    values (l_user_rec.user_id, l_activation_key, l_link);

    l_values('SystemOwnerName')(1) := l_cc_rec.cc_name;
    l_values('UserFirstLastName')(1) := l_user_rec.user_first_name || ' ' || l_user_rec.user_last_name;
    l_values('UserLoginName')(1) := l_user_rec.user_name;
    l_values('Link')(1) := '<a href="'||l_link||'?reset='||l_activation_key||'">here</a>';
    l_values('InterfaceNames')(1) := get_interface_names(l_user_rec, l_cc_rec);


    prv_mail_utils.send_email
    (
      p_recipient => l_email,
      p_subject => prv_exp_utils.get_replaced
      (
        bas_utils.get_template_ext_info(l_letter_template_id, null, l_cc_id),
        l_values
      ),
      p_message => prv_exp_utils.get_replaced
      (
        bas_utils.get_template_blob(l_letter_template_id, null, l_cc_id),
        l_values
      ),
      p_mail_server_type_id => l_mail_acc,
      p_cc_id => l_cc_id
    );


  end;
  -----------------------------------------------------------------------------------------------
  --Wrapper for inVoice UI
  procedure request_password_reset(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table)
  is
    l_param prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'name_or_email,link');
  begin  
    enable_disable_vpd('disable');
    request_password_reset(l_param('name_or_email'), l_param('link'));
    enable_disable_vpd('enable');
    exception when others then
      enable_disable_vpd('enable');
      raise;
  end;
  -----------------------------------------------------------------------------------------------
  procedure change_password(p_user_id number, p_new_pwd varchar2, p_link varchar2 := null)
  is
    c_min_pwd_len         constant number := nvl(nullif(prv_utils.get_param('SEC-MIN_PASSWORD_LENGTH'), 'null'), 8);
    c_min_letter_cnt      constant number := nvl(nullif(prv_utils.get_param('SEC-MIN_LETTER_COUNT'), 'null'), 3);
    c_min_mixed_case_cnt  constant number := nvl(nullif(prv_utils.get_param('SEC-MIN_DIFF_CASE_LETTER_COUNT'), 'null'), 2);
    c_min_digit_cnt       constant number := nvl(nullif(prv_utils.get_param('SEC-MIN_DIGIT_COUNT'), 'null'), 3);
    c_min_aux_symbol_cnt  constant number := nvl(nullif(prv_utils.get_param('SEC-MIN_AUX_SYMBOL_COUNT'), 'null'), 2);
    c_aux_symbols         constant prv_param.param_value%type := nvl(nullif(prv_utils.get_param('SEC-AUX_SYMBOLS'), 'null'), '!@#$%^&*()-+=.,;');
    --
    l_user_rec            bas_user%rowtype := bas_car_utils.get_user_rec(p_user_id);
    l_cc_id               bas_contract_company.cc_id%type := get_cc_id(l_user_rec.user_car_id);
    l_cc_rec              bas_contract_company%rowtype := get_cc_rec(l_cc_id);
    l_values              prv_exp_utils.values_t;
    l_email               bas_user_info.info_value%type := get_user_email(l_user_rec.user_id);
    l_template_id         bas_template.template_type_id%type;
    l_mail_acc            prv_mail_server.mail_server_type_id%type;
  begin

    if l_user_rec.user_id is null then
      raise_application_error(-20000, prv_utils.get_message('ERR-USER_NOT_FOUND', p_user_id));
    end if;
    
    --Validate password    
    if not bas_car_utils.validate_password_text(p_user_id, p_new_pwd) then
      raise_application_error
      (
        -20000,
        prv_utils.get_message
        (
          'ERR-PASSWORD-POLICY-VIOLATED',
          c_min_pwd_len,
          c_min_digit_cnt,
          c_min_letter_cnt,
          c_min_mixed_case_cnt,
          c_min_aux_symbol_cnt,
          c_aux_symbols
        )
      );
    end if;
    
    --Change password    
    update bas_user
    set user_password = prv_utils.md5(user_name || p_new_pwd || l_user_rec.user_salt),
      user_active = 1,
      user_expire_date = greatest(coalesce(user_expire_date, trunc(sysdate)), trunc(sysdate) + to_number(prv_utils.get_param('SEC-PASSWORD_EXPIRY_PERIOD'))),
      user_left_auth = greatest(coalesce(user_left_auth, 1), to_number(prv_utils.get_param('SEC-GRACE_LOGIN_COUNT')))
    where user_id = p_user_id
    returning user_password into l_user_rec.user_password;

    --Add password cache
    insert into bas_password_cache
    (
      pwd_id,
      pwd_user_id,
      pwd_hash,
      pwd_created
    )
    values
    (
      bas_password_cache_id_seq.nextval,
      p_user_id,
      l_user_rec.user_password,
      sysdate
    );

    if l_user_rec.user_car_id = 1 then

      l_template_id := bas_utils.c_bas_user_update_pwd_letter;
      l_mail_acc := prv_mail_utils.c_default_mail_server;
      l_values('Link')(1) := coalesce(p_link, prv_utils.get_param('PARAM-APP-URL'));
      l_values('UILink')(1) := prv_utils.get_param('PARAM-APP-URL');
      l_values('PortalLink')(1) := null;
      l_values('SelfcareLink')(1) := null;

    else

      l_template_id := bas_utils.c_clp_user_update_pwd_letter;
      l_mail_acc := prv_mail_utils.c_clp_mail_server;

      --Partner user
      l_values('UILink')(1) := null;
      l_values('PortalLink')(1) := case 
        when is_partner_portal_user(l_user_rec.user_id) then 
          nvl(l_cc_rec.cc_partner_url, prv_utils.get_param('CLP-URL'))
        end;
      l_values('SelfcareLink')(1) := case 
        when is_selfcare_user(l_user_rec.user_id) then 
          nvl(l_cc_rec.cc_selfcare_url, prv_utils.get_param('CLP-SELFCARE_URL'))
        end;

      --Final link
      l_values('Link')(1) := coalesce
      (
        p_link, 
        l_values('SelfcareLink')(1),
        l_values('PortalLink')(1)
      );      

      
    end if;

    l_values('SystemOwnerName')(1) := l_cc_rec.cc_name;
    l_values('UserFirstLastName')(1) := l_user_rec.user_first_name || ' ' || l_user_rec.user_last_name;
    l_values('UserLoginName')(1) := l_user_rec.user_name;
    l_values('PasswordExpireDate')(1) := nvl(to_char(l_user_rec.user_expire_date, prv_var.c_def_date_fmt), 'never');
    l_values('InterfaceNames')(1) := get_interface_names(l_user_rec, l_cc_rec);

    prv_mail_utils.send_email
    (
      p_recipient => l_email,
      p_subject => prv_exp_utils.get_replaced
      (
        bas_utils.get_template_ext_info(l_template_id, null, l_cc_id),
        l_values
      ),
      p_message => prv_exp_utils.get_replaced
      (
        bas_utils.get_template_blob(l_template_id, null, l_cc_id),
        l_values
      ),
      p_mail_server_type_id => l_mail_acc,
      p_cc_id => l_cc_id
    );

  end;
  -----------------------------------------------------------------------------------------------
  --Wrapper for inVoice UI
  procedure change_password_using_key(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table)
  is
    l_param prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'key,new_pwd');
  begin  
    enable_disable_vpd('disable');
    change_password_using_key(l_param('key'), l_param('new_pwd'));
    enable_disable_vpd('enable');
    exception when others then
      enable_disable_vpd('enable');
      raise;
  end;
  -----------------------------------------------------------------------------------------------
  procedure change_password_using_key(p_key varchar2, p_new_pwd varchar2)
  is
    l_res     bas_reset_pwd%rowtype;
  begin

    begin
      select *
      into l_res
      from bas_reset_pwd r
      where r.activation_key = p_key
      for update;
    exception 
      when no_data_found then
        raise_application_error(-20000, prv_utils.get_message('BAS-ERR-ACTIVATION-KEY-INVALID-EXPIRED'));
      when too_many_rows then
        raise_application_error(-20000, prv_utils.get_message('BAS-ERR-ACTIVATION-KEY-INVALID'));
    end;

    change_password(l_res.user_id, p_new_pwd, l_res.link);
    
    delete from bas_reset_pwd
    where activation_key = p_key;
  
  end;
  -----------------------------------------------------------------------------------------------
  procedure send_change_error_alert(p_user_id number)
  is
    pragma autonomous_transaction;
    l_user_rec    bas_user%rowtype := bas_car_utils.get_user_rec(p_user_id);
    l_cc_id       bas_contract_company.cc_id%type := get_cc_id(l_user_rec.user_car_id);
    l_values      prv_exp_utils.values_t;
    l_email       bas_user_info.info_value%type := get_user_email(l_user_rec.user_id);
    l_template_id bas_template.template_type_id%type := case 
        when l_user_rec.user_car_id = 1 then 
          bas_utils.c_bas_user_error_pwd_letter 
        else 
          bas_utils.c_clp_user_error_pwd_letter
      end;
    l_mail_acc    prv_mail_server.mail_server_type_id%type := case
        when l_user_rec.user_car_id = 1 then
          prv_mail_utils.c_default_mail_server
        else
          prv_mail_utils.c_clp_mail_server
      end;
  begin
    
    l_values('SystemOwnerName')(1) := bas_utils.get_cc_rec(l_cc_id).cc_name;
    l_values('UserFirstLastName')(1) := l_user_rec.user_first_name || ' ' || l_user_rec.user_last_name;
    l_values('UserLoginName')(1) := l_user_rec.user_name;

    prv_mail_utils.send_email
    (
      p_recipient => l_email,
      p_subject => prv_exp_utils.get_replaced
      (
        bas_utils.get_template_ext_info(l_template_id, null, l_cc_id),
        l_values
      ),
      p_message => prv_exp_utils.get_replaced
      (
        bas_utils.get_template_blob(l_template_id, null, l_cc_id),
        l_values
      ),
      p_mail_server_type_id => l_mail_acc,
      p_cc_id => l_cc_id
    );
    
    commit;
  
  
  end;
  -----------------------------------------------------------------------------------------------
  procedure change_password_using_old_pwd(p_old_pwd varchar2, p_new_pwd varchar2)
  is
    l_user_id bas_user.user_id%type;
  begin
    --Check user env, user must by authorized
    begin    
      select user_id
      into l_user_id
      from bas_user
      where user_password = prv_utils.md5(user_name || p_old_pwd || user_salt)
      and user_id = bas_utils.get_user_id;
    exception when no_data_found then
      send_change_error_alert(bas_utils.get_user_id);
      raise_application_error(-20000, prv_utils.get_message('BAS-ERR-OLD-PASSWORD-INCORRECT'));
    end;    
    
    change_password(l_user_id, p_new_pwd);
    
  end;
  -----------------------------------------------------------------------------------------------
  procedure set_user_lang(p_lang varchar2) is
  begin

    update bas_user
    set user_lang = p_lang
    where user_name = sys_context('user_ctx', 'user_name')
    and nvl(user_lang, '-') <> p_lang;

    prv_utils.set_lang(p_lang);

    commit;
  end;
  -----------------------------------------------------------------------------------------------
  function get_user_lang return sys_refcursor
  is
    l_cur sys_refcursor;
  begin
    open l_cur for select prv_utils.get_lang from dual;
    return l_cur;
  end;
  -----------------------------------------------------------------------------------------------
  procedure set_user_settings(p_settings_json varchar2)
  is
  begin

    update bas_user
    set user_settings = p_settings_json
    where user_name = sys_context('user_ctx', 'user_name')
    and nvl(user_settings, '-') <> p_settings_json
    and p_settings_json is json;
    
    commit;

  end;
  -----------------------------------------------------------------------------------------------
  function get_user_settings return varchar2
  is
    l_res bas_user.user_settings%type;
  begin  

    select user_settings
    into l_res
    from bas_user
    where user_name = sys_context('user_ctx', 'user_name');
    
    return l_res;

  end;
  -----------------------------------------------------------------------------------------------
  function get_account_cc(p_acc_id number)
  return number result_cache
  is
    l_cc_id number;
  begin
    select car_cc_id
    into l_cc_id
    from bas_carrier c
    inner join bas_account a on (c.car_id = a.acc_car_id)
    where acc_id = p_acc_id;
    return l_cc_id;
  exception
    when no_data_found then
      return null;
  end;
  -----------------------------------------------------------------------------------------------
  procedure update_menu_item
  (
    p_item_code         varchar2,
    p_parent_item_code  varchar2,
    p_role_code         varchar2,
    p_item_type         varchar2,
    p_item_order        number default null
  )
  is
  begin
    merge into bas_menu m
    using
    (
      select 
        p_item_code as menu_item_code,
        p_parent_item_code as menu_item_parent_item_code,
        p_role_code as menu_item_role_code,
        p_item_type as menu_item_type,
        p_item_order as menu_item_order
      from dual
    ) s
      on (m.menu_item_code = s.menu_item_code)
    when matched then
      update set
        m.menu_item_parent_item_code =s.menu_item_parent_item_code,
        m.menu_item_role_code = s.menu_item_role_code,
        m.menu_item_type = s.menu_item_type,
        m.menu_item_order = nvl(s.menu_item_order, m.menu_item_order)
    when not matched then
      insert (menu_item_code, menu_item_parent_item_code, menu_item_role_code, menu_item_type, menu_item_order)
      values (s.menu_item_code, s.menu_item_parent_item_code, s.menu_item_role_code, s.menu_item_type, nvl(s.menu_item_order, 0));
  end;
  -----------------------------------------------------------------------------------------------
  procedure delete_menu_item(p_menu_item_code varchar2) is
  begin
    delete from bas_menu
    where menu_item_code = p_menu_item_code;
  end;
  -----------------------------------------------------------------------------------------------
  function get_currency_rate(p_currency_code varchar2, p_date date, p_leg number := null) return number result_cache is
    l_rate number;
  begin

    if p_currency_code = prv_var.c_server_currency_code then
      return 1;
    else
      select / *+ INDEX_DESC(bas_currency_rate bas_currency_rate_unq) * / currency_rate
        + case 
            when p_leg is not null and spread_pct is not null then
              sign(p_leg - 0.5) * currency_rate * spread_pct / 200
            else
              0
          end
      into l_rate
      from bas_currency_rate
      where currency_code = p_currency_code
      and currency_rate_date <= p_date
      and rownum = 1;

      return l_rate;
    end if;
  exception
    when no_data_found then
      return null;
  end;
  -----------------------------------------------------------------------------------------------
  procedure update_currency(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table)
  is
    l_param prv_utils.param_t := prv_utils.transform_params
    (
      p_names,
      p_values,
      'currency_id,currency_code,currency_display_name'
    );
  begin

    l_param('currency_id') := nvl(l_param('currency_id'), bas_currency_id_seq.nextval);
    
    merge into bas_currency
    using dual
    on (currency_id = l_param('currency_id'))
    when matched then
      update set
        currency_code = l_param('currency_code'),
        currency_name = l_param('currency_display_name')
    when not matched then
      insert
      (
        currency_id,
        currency_code,
        currency_name
      )
      values
      (
        l_param('currency_id'),
        l_param('currency_code'),
        l_param('currency_display_name')
      );

    prv_var.m_rows_affected := sql%rowcount;
    prv_var.m_last_id := l_param('currency_id');

  end;
  -----------------------------------------------------------------------------------------------
  procedure delete_currency(p_currency_id number) is
  begin
    delete from bas_currency
    where currency_id = p_currency_id;
    
    prv_var.m_rows_affected := sql%rowcount;
  end;
  -----------------------------------------------------------------------------------------------
  procedure update_currency_rate(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) is
    l_param prv_utils.param_t := prv_utils.transform_params
    (
      p_names,
      p_values,
      'new_currency_code,old_currency_code,new_currency_date,old_currency_date,new_currency_rate,new_spread_pct'
    );
  begin

    if l_param('new_currency_code') = prv_var.c_server_currency_code then

      return;

    else
      
      if l_param('old_currency_code') is not null 
        and l_param('old_currency_date') is not null 
      then
      
        update bas_currency_rate
        set currency_rate = l_param('new_currency_rate'),
          currency_code = l_param('new_currency_code'),
          currency_rate_date = l_param('new_currency_date'),
          spread_pct = l_param('new_spread_pct')
        where currency_code = l_param('old_currency_code')
        and currency_rate_date = l_param('old_currency_date');

      else

        insert into bas_currency_rate (currency_code, currency_rate_date, currency_rate, spread_pct)
        values (l_param('new_currency_code'), l_param('new_currency_date'), l_param('new_currency_rate'), l_param('new_spread_pct'));

      end if;

      prv_var.m_rows_affected := sql%rowcount;

    end if;

  end;
  -----------------------------------------------------------------------------------------------
  procedure delete_currency_rate(p_currency_code varchar2, p_date date) is
    l_date date := trunc(p_date);
  begin
    delete from bas_currency_rate
    where currency_code=p_currency_code
    and currency_rate_date=l_date;
  end;
  -----------------------------------------------------------------------------------------------
  function get_currency_code_list return sys_refcursor is
    l_cur sys_refcursor;
  begin
    open l_cur for
    select currency_code,currency_id,currency_name currency_display_name
    from bas_currency
    order by currency_code;

    return l_cur;
  end;
  -----------------------------------------------------------------------------------------------
  function get_currency_rate_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table)
  return sys_refcursor
  is
    l_param prv_utils.param_t := prv_utils.transform_params
    (
      p_names,
      p_values,
      'currency_code,from_date,till_date,show_actual_rates'
    );
    l_cur sys_refcursor;
  begin

    open l_cur for
    select currency_code, currency_rate_date, currency_rate, spread_pct
    from
    (
      select currency_code,
        currency_rate_date,
        to_char(currency_rate) currency_rate,
        spread_pct,
        row_number() over(partition by currency_code order by currency_rate_date desc nulls last) n
      from bas_currency_rate
      where (l_param('currency_code') is null or currency_code = l_param('currency_code'))
      and (l_param('from_date') is null or currency_rate_date >= l_param('from_date'))
      and (l_param('till_date') is null or currency_rate_date <= l_param('till_date'))
      and 
      (
        l_param('show_actual_rates') is null 
        or (l_param('show_actual_rates') = 1 and  currency_rate_date <= sysdate)
      )
    ) t
    where
    (
      (t.n = 1 and l_param('show_actual_rates') = 1)
      or (l_param('from_date') is not null and l_param('till_date') is not null)
    )
    order by currency_rate_date desc;

    return l_cur;
  end;
  -----------------------------------------------------------------------------------------------
  function convert_currency
  (
    p_amount              number,
    p_from_currency_code  varchar2,
    p_to_currency_code    varchar2 := prv_var.c_server_currency_code,
    p_date                date := sysdate,
    p_timezone            number := nvl(sys_context('user_ctx', 'user_time_offset'), 0),
    p_leg                 number := null
  ) 
  return number 
  is
    l_date date := p_date - p_timezone/24;
  begin

    if p_from_currency_code = p_to_currency_code then
      return p_amount;
    else
      return p_amount * get_currency_rate(p_from_currency_code, l_date, p_leg) / get_currency_rate(p_to_currency_code, l_date, p_leg);
    end if;

  end;
  -----------------------------------------------------------------------------------------------
  function get_currency_decode(p_currency_code varchar2, p_date date) return varchar2 is
    l_res varchar2(4000);
  begin

    select listagg
      (
        chr(39)||currency_code||chr(39)||', '
          ||nvl(bas_utils.convert_currency(1, currency_code, p_currency_code, p_date), 0),
        ', '
      ) within group (order by 1)
    into l_res
    from bas_currency;

    return l_res;

  end;
  -----------------------------------------------------------------------------------------------
  procedure check_or_add_country_and_type(p_country varchar2, p_type varchar2)
  is
    l_country_exists  number(1);
    l_type_exists     number(1);
  begin  

    --Check country and type
    select
      (select 1 from bas_dial_code_country where country_name = p_country),
      (select 1 from bas_dial_code_type where type_name = p_type)
    into l_country_exists, l_type_exists
    from dual;

    if l_country_exists is null and p_country <> prv_var.c_not_exists_val then
      insert into bas_dial_code_country (country_name, country_id)
      values (p_country, bas_dial_code_country_id_seq.nextval);
    end if;

    if l_type_exists is null and p_type <> prv_var.c_not_exists_val then
      insert into bas_dial_code_type (type_name, type_id)
      values (p_type, bas_dial_code_type_id_seq.nextval);
    end if;  
  
  end;
  -----------------------------------------------------------------------------------------------
  procedure delete_unused_country_and_type
  is
  begin
  
    delete from bas_dial_code_country
    where country_name not in
    (
      select dial_code_country
      from bas_dial_code
      union
      select new_dial_code_country
      from bas_dial_code_pending
      where new_dial_code_country is not null
    );

    delete from bas_dial_code_type
    where type_name not in
    (
      select dial_code_type
      from bas_dial_code
      union
      select new_dial_code_type
      from bas_dial_code_pending
      where new_dial_code_type is not null
    );

  end;
  -----------------------------------------------------------------------------------------------
  procedure update_dial_code(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table)
  is
    l_param           prv_utils.param_t := prv_utils.transform_params
    (
      p_names, 
      p_values, 
      'dial_code,dial_code_country,dial_code_region,dial_code_type,skip_delete_unused', 
      true
    );
  begin

    check_or_add_country_and_type
    (
      l_param('dial_code_country'), 
      l_param('dial_code_type')
    );

    update bas_dial_code set
      dial_code_country = prv_utils.convert(dial_code_country, l_param('dial_code_country')),
      dial_code_region = prv_utils.convert(dial_code_region, l_param('dial_code_region')),
      dial_code_type = prv_utils.convert(dial_code_type, l_param('dial_code_type'))
    where dial_code = l_param('dial_code');
    
    if sql%rowcount = 0 then
      insert into bas_dial_code (dial_code, dial_code_country, dial_code_region, dial_code_type)
      values (l_param('dial_code'), l_param('dial_code_country'), l_param('dial_code_region'), l_param('dial_code_type'))
      returning dial_code into prv_var.m_last_id;
    end if;

    prv_var.m_rows_affected := sql%rowcount;

    fix_country_code(l_param('dial_code'));
    
    if l_param('skip_delete_unused') is null then
      delete_unused_country_and_type;
    end if;

  end;
  -----------------------------------------------------------------------------------------------
  function batch_update_dial_code
  (
    p_names       dbms_sql.varchar2_table,
    p_values      dbms_sql.varchar2_table,
    p_upd_names   dbms_sql.varchar2_table,
    p_upd_values  dbms_sql.varchar2_table
  )
  return number
  is
    l_cur         sys_refcursor;
    l_param       prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'multiedit_ids,multiedit_selection_mode');
    l_upd_param   prv_utils.param_t := prv_utils.transform_params(p_upd_names, p_upd_values);
    l_names       dbms_sql.varchar2_table := prv_utils.str2plsqltable('dial_code,dial_code_country,dial_code_region,dial_code_type,skip_delete_unused', ',');
    l_values      dbms_sql.varchar2_table;
    l_cnt         number := 0;

    type rec_t is record
    (
      dial_code               bas_dial_code.dial_code%type,
      dial_code_country       bas_dial_code.dial_code_country%type,
      dial_code_region        bas_dial_code.dial_code_region%type,
      dial_code_type          bas_dial_code.dial_code_type%type,
      dial_code_destination   bas_dial_code.dial_code_destination%type,
      cnt                     number
     );
     type array_t is table of rec_t;
     l_rows array_t;
  begin

    l_cur := get_dial_code_list(p_names, p_values, prv_utils.str2plsqltable(l_param('multiedit_ids'), ','));
    fetch l_cur bulk collect into l_rows;
    close l_cur;

    if l_param('multiedit_ids') is null and l_param('multiedit_selection_mode') = 1 then
      return 0;

    elsif l_rows.count > 0 then

      prv_var.m_skip_event_sending := 1;

      for i in l_rows.first..l_rows.last loop

        l_values(1) := l_rows(i).dial_code;
        l_values(2) := case when l_upd_param.exists('dial_code_country') then l_upd_param('dial_code_country') else l_rows(i).dial_code_country end;
        l_values(3) := case when l_upd_param.exists('dial_code_region') then l_upd_param('dial_code_region') else l_rows(i).dial_code_region end;
        l_values(4) := case when l_upd_param.exists('dial_code_type') then l_upd_param('dial_code_type') else l_rows(i).dial_code_type end;
        l_values(5) := '1';
        update_dial_code(l_names, l_values);

        l_cnt := l_cnt + 1;
      end loop;

      delete_unused_country_and_type;
      
      prv_var.m_skip_event_sending := null;

      --Send event to uidisp
      prv_msg_utils.send_event('BAS_DIAL_CODE');

    end if;

    return l_cnt;

  end;
  -----------------------------------------------------------------------
  procedure delete_dial_code(p_dial_codes dbms_sql.varchar2_table) 
  is
    l_products    varchar2(4000);
    l_dial_codes  prv_varchar4000_table_t := prv_utils.cast_plsqltable2table(p_dial_codes);
  begin

    begin
      select listagg(rate_product_id, ',') within group (order by 1)
      into l_products
      from rat_rate
      where rate_dial_code in (select column_value from table(l_dial_codes))
      and rownum < 50;
    exception when no_data_found then
      null;
    end;

    if l_products is not null then
      raise_application_error(-20000, prv_utils.get_message('BAS-ERR-DEL-DIAL-CODE', l_products));
    end if;

    delete from bas_dial_code
    where dial_code in (select column_value from table(l_dial_codes));
    
    delete_unused_country_and_type;

  end;
  -----------------------------------------------------------------------------------------------
  function get_dial_code_list
  (
    p_names           dbms_sql.varchar2_table,
    p_values          dbms_sql.varchar2_table,
    p_dial_code_list  dbms_sql.varchar2_table default cast(null as dbms_sql.varchar2_table),
    p_dest_list       dbms_sql.varchar2_table default cast(null as dbms_sql.varchar2_table)
  )
  return sys_refcursor
  is
    l_cur sys_refcursor;
    l_param                 prv_utils.param_t :=
      prv_utils.transform_params
      (
        p_names,p_values,
        'dial_code,dial_code_country,dial_code_region,dial_code_type,rate_product_id,first_rec,rec_count,multiedit_selection_mode'
      );
    l_dial_code_tab         prv_varchar4000_table_t := prv_utils.cast_plsqltable2table(p_dial_code_list);
    l_dest_tab              prv_varchar4000_table_t := prv_utils.cast_plsqltable2table(p_dest_list);
    l_dial_code_tab_count   number;
    l_dest_tab_count        number;
    l_product_id            number := l_param('rate_product_id');
  begin
    l_dial_code_tab_count := l_dial_code_tab.count;
    l_dest_tab_count := l_dest_tab.count;
    l_param('multiedit_selection_mode') := nvl(l_param('multiedit_selection_mode'), '1');

    if l_product_id is null then

      if p_names.count = 0 and p_dest_list.count = 0 and p_dial_code_list.count > 0 then

        open l_cur for
        select / *+ index(dc bas_dial_code_pk) * / 
          dial_code, dial_code_country, dial_code_region, dial_code_type, dial_code_destination,
          count(*) over() as cnt
        from bas_dial_code dc
        where dial_code in (select column_value from table(l_dial_code_tab));

      else

        open l_cur for
        select
          dial_code, dial_code_country, dial_code_region, dial_code_type, dial_code_destination,
          decode(rn,nvl(l_param('first_rec'),1),cnt,null) as cnt
        from
        (
          select
            dial_code, dial_code_country, dial_code_region, dial_code_type, dial_code_destination,
            count(*) over() as cnt,
            row_number() over(order by dial_code) as rn
          from bas_dial_code
          where (l_param('dial_code') is null or dial_code like replace(l_param('dial_code'), '*', '%'))
          and (l_param('dial_code_country') is null or lower(dial_code_country) like replace(lower(l_param('dial_code_country')), '*', '%'))
          and (l_param('dial_code_region') is null or lower(dial_code_region) like replace(lower(l_param('dial_code_region')), '*', '%'))
          and (l_param('dial_code_type') is null or lower(dial_code_type) like replace(lower(l_param('dial_code_type')), '*', '%'))
          and (l_dest_tab_count=0 or dial_code_destination in (select column_value from table(l_dest_tab)))
          and
          (
            l_dial_code_tab_count=0
            or (l_param('multiedit_selection_mode') = 1 and dial_code in (select column_value from table(l_dial_code_tab)))
            or (l_param('multiedit_selection_mode') = -1 and dial_code not in (select column_value from table(l_dial_code_tab)))
          )
        )
        where (l_param('first_rec') is null or l_param('rec_count') is null or (rn>=l_param('first_rec') and rn<l_param('first_rec')+l_param('rec_count')))
        order by rn;

      end if;

    else

      open l_cur for
      select
        dial_code, dial_code_country, dial_code_region, dial_code_type, dial_code_destination,
        decode(rn,nvl(l_param('first_rec'),1),cnt,null) as cnt
      from
      (
        select
          dial_code, dial_code_country, dial_code_region, dial_code_type, dial_code_destination,
          count(*) over() as cnt,
          row_number() over(order by dial_code) as rn
        from
        (
          select
            dial_code,
            rtrim(substr(val, 1, 256)) dial_code_country,
            rtrim(substr(val, 257, 256)) dial_code_region,
            rtrim(substr(val, 513, 256)) dial_code_type,
            rtrim(substr(val, 769, 256)) dial_code_destination
          from
          (
            select
              rate_dial_code as dial_code,
              (
                select
                  rpad(dial_code_country,256)||rpad(nvl(dial_code_region,' '),256)||rpad(dial_code_type,256)||rpad(dial_code_destination,256)
                from bas_dial_code
                where dial_code = rate_dial_code
              ) val
            from rat_rate r
            where r.rate_product_id = l_product_id
            and r.rate_start_date <= sysdate
            and r.rate_end_date > sysdate
            and (l_param('dial_code') is null or rate_dial_code like replace(l_param('dial_code'), '*', '%'))
          )
        )
        where (l_param('dial_code_country') is null or lower(dial_code_country) like replace(lower(l_param('dial_code_country')), '*', '%'))
        and (l_param('dial_code_region') is null or lower(dial_code_region) like replace(lower(l_param('dial_code_region')), '*', '%'))
        and (l_param('dial_code_type') is null or lower(dial_code_type) like replace(lower(l_param('dial_code_type')), '*', '%'))
        and (l_dest_tab_count=0 or dial_code_destination in (select column_value from table(l_dest_tab)))
        and
        (
          l_dial_code_tab_count=0
          or (l_param('multiedit_selection_mode') = 1 and dial_code in (select column_value from table(l_dial_code_tab)))
          or (l_param('multiedit_selection_mode') = -1 and dial_code not in (select column_value from table(l_dial_code_tab)))
        )
      )
      where (l_param('first_rec') is null or l_param('rec_count') is null or (rn>=l_param('first_rec') and rn<l_param('first_rec')+l_param('rec_count')))
      order by rn;

    end if;

    return l_cur;
  end;
  -----------------------------------------------------------------------------------------------
  function export_dial_code_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return blob
  is
    l_param       prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'report_header');
    l_cur         sys_refcursor;
    l_column_list varchar2(4000);
    l_column_capt varchar2(4000);
  begin

    l_cur := get_dial_code_list(p_names, p_values);
    l_column_list := 'DIAL_CODE,DIAL_CODE_COUNTRY,DIAL_CODE_REGION,DIAL_CODE_TYPE';
    l_column_capt := 'Dial code;Country|W200;Region|W200;Type';

    return
      prv_exp_utils.export2doc
      (
        l_cur,
        l_column_list,
        l_param('report_header'),
        l_column_capt
      );
  end;
  -----------------------------------------------------------------------------------------------
  function get_destination_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
    l_cur   sys_refcursor;
    l_param prv_utils.param_t := prv_utils.transform_params(p_names,p_values,'destination_str,product_id,car_id,first_rec,rec_count');
  begin
    if l_param('product_id') is not null then

      open l_cur for
      select dial_code_destination, decode(rn,nvl(l_param('first_rec'),1),cnt,null) cnt
      from
      (
        select
          dial_code_destination,
          row_number() over(order by dial_code_destination) rn,
          count(1) over() cnt
        from
        (
          select distinct dial_code_destination
          from bas_dial_code
          inner join rat_rate on (rate_product_id = l_param('product_id') and dial_code = rate_dial_code)
          where (l_param('destination_str') is null or lower(dial_code_destination) like replace(lower(l_param('destination_str')),'*','%')||'%')
        )
      )
      where (l_param('first_rec') is null or l_param('rec_count') is null or (rn>=l_param('first_rec') and rn<l_param('first_rec')+l_param('rec_count')))
      order by rn;

    elsif l_param('car_id') is not null then

      open l_cur for
      select dial_code_destination, decode(rn,nvl(l_param('first_rec'),1),cnt,null) cnt
      from
      (
        select
          dial_code_destination,
          row_number() over(order by dial_code_destination) rn,
          count(1) over() cnt
        from
        (
          select distinct dial_code_destination
          from bas_dial_code
          inner join rat_rate on (dial_code = rate_dial_code)
          where rate_product_id in (select product_id from bas_product_v where car_id = l_param('car_id'))
          and (l_param('destination_str') is null or lower(dial_code_destination) like replace(lower(l_param('destination_str')),'*','%')||'%')
        )
      )
      where (l_param('first_rec') is null or l_param('rec_count') is null or (rn>=l_param('first_rec') and rn<l_param('first_rec')+l_param('rec_count')))
      order by rn;

    else

      open l_cur for
      select dial_code_destination, decode(rn,nvl(l_param('first_rec'),1),cnt,null) cnt
      from
      (
        select
          dial_code_destination,
          row_number() over(order by dial_code_destination) rn,
          count(1) over() cnt
        from
        (
          select distinct dial_code_destination
          from bas_dial_code
          where (l_param('destination_str') is null or lower(dial_code_destination) like replace(lower(l_param('destination_str')),'*','%')||'%')
        )
      )
      where (l_param('first_rec') is null or l_param('rec_count') is null or (rn>=l_param('first_rec') and rn<l_param('first_rec')+l_param('rec_count')))
      order by rn;

    end if;

    return l_cur;

  end;
  -----------------------------------------------------------------------------------------------
  function get_dial_code_country_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
    l_param   prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'country_pattern,first_rec,rec_count');
    l_cur     sys_refcursor;
  begin
    open l_cur for
    select
      country_id, country_name, country_region_id,
      decode(rownum, 1, cnt, null) cnt
    from
    (
      select
        country_id, country_name, country_region_id,
        rownum as rn, count(*) over() as cnt
      from bas_dial_code_country
      where (l_param('country_pattern') is null or lower(country_name) like replace(lower(l_param('country_pattern')),'*','%')||'%')
    )
    where l_param('first_rec') is null
      or l_param('rec_count') is null
      or (rn >= l_param('first_rec') and rn < l_param('first_rec') + l_param('rec_count'))
    order by country_name;
    
    return l_cur;
  end;
  -----------------------------------------------------------------------------------------------
  procedure update_dial_code_country(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table)
  is
    l_param prv_utils.param_t := prv_utils.transform_params(p_names,p_values,'country_id,region_id');
  begin
    update bas_dial_code_country set
      country_region_id = l_param('region_id')
    where country_id = l_param('country_id');
  end;
  -----------------------------------------------------------------------------------------------
  function get_country_region_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
    l_param   prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'country,region_pattern,first_rec,rec_count');
    l_cur     sys_refcursor;
  begin
    open l_cur for
    select
      dial_code_region,
      dial_code_country,
      decode(rownum, 1, cnt, null) cnt
    from
    (
      select
        dial_code_region,
        dial_code_country,
        row_number() over(order by dial_code_region) as rn,
        count(*) over() as cnt
      from
      (
        select distinct dial_code_region, dial_code_country
        from bas_dial_code
        where (l_param('country') is null or dial_code_country = l_param('country'))
          and (l_param('region_pattern') is null or lower(dial_code_region) like replace(lower(l_param('region_pattern')),'*','%')||'%')
          and dial_code_region is not null
      )
    )
    where l_param('first_rec') is null
      or l_param('rec_count') is null
      or (rn >= l_param('first_rec') and rn < l_param('first_rec') + l_param('rec_count'))
    order by 1;
    
    return l_cur;
  end;
  -----------------------------------------------------------------------------------------------
  function get_dial_code_region_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
    l_param   prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'dial_code_region,first_rec,rec_count');
    l_cur     sys_refcursor;
  begin
    open l_cur for
    select
      dial_code_region,
      decode(rownum, 1, cnt, null) cnt
    from
    (
      select
        dial_code_region,
        row_number() over(order by dial_code_region) as rn,
        count(*) over() as cnt
      from
      (
        select distinct dial_code_region
        from bas_dial_code
        where (l_param('dial_code_region') is null or lower(dial_code_region) like replace(lower(l_param('dial_code_region')),'*','%')||'%')
      )
    )
    where l_param('first_rec') is null
      or l_param('rec_count') is null
      or (rn >= l_param('first_rec') and rn < l_param('first_rec') + l_param('rec_count'))
    order by 1;
    
    return l_cur;
  end;
  -----------------------------------------------------------------------------------------------
  function get_dial_code_type_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
    l_param   prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'type_pattern');
    l_cur     sys_refcursor;
  begin
    open l_cur for
    select
      type_id, type_name, 
      decode(rownum, 1, cnt, null) cnt
    from
    (
      select
        type_id, type_name,
        rownum as rn,
        count(*) over() as cnt
      from bas_dial_code_type
      where (l_param('type_pattern') is null or lower(type_name) like replace(lower(l_param('type_pattern')),'*','%')||'%')
    )
    order by type_name;

    return l_cur;
  end;
  -----------------------------------------------------------------------------------------------
  function get_country_code_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
    l_param   prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'country,country_dial_code,orderby_clause');
    l_cur     sys_refcursor;
  begin
    
    open l_cur for
    select
      record_id, 
      country, 
      country_dial_code, 
      decode(rownum, 1, cnt, null) cnt
    from
    (
      select
        record_id, 
        country, 
        country_dial_code,
        row_number() over
        (
          order by
            decode
            (
              l_param('orderby_clause'),
              'country ASC',          country,
              'country_dial_code ASC', country_dial_code,
              null
            ) asc nulls first,
            decode
            (
              l_param('orderby_clause'),
              'country DESC',          country,
              'country_dial_code DESC', country_dial_code,
              null
            ) desc nulls first
        ) rn,
        count(*) over() cnt
      from bas_country_code
      where (l_param('country') is null or lower(country) like replace(lower(l_param('country')), '*', '%') || '%')
      and (l_param('country_dial_code') is null or country_dial_code like replace(l_param('country_dial_code'), '*', '%') || '%')      
    )
    order by rn;

    return l_cur;
  end;
  -----------------------------------------------------------------------------------------------
  procedure update_country_code(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table)
  is
    l_param   prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'record_id,country,country_dial_code', true);
  begin
  
    if l_param('record_id') != prv_var.c_not_exists_val then
      --Update record
      update bas_country_code set
        country =           prv_utils.convert(country, l_param('country')),
        country_dial_code = prv_utils.convert(country_dial_code, l_param('country_dial_code'))
      where record_id = to_number(l_param('record_id'));
    else
      --Add new
      insert into bas_country_code (record_id, country, country_dial_code)
      values (bas_country_code_id_seq.nextval, l_param('country'), l_param('country_dial_code'));
    end if;
  
  end;
  -----------------------------------------------------------------------------------------------
  procedure delete_country_code(p_record_id number)
  is
  begin  

    delete from bas_country_code
    where record_id = p_record_id;

  end;
  -----------------------------------------------------------------------------------------------
  function get_carrier_name(p_car_id number) return varchar2
  is
    l_name varchar2(256);
  begin
    select car_name
    into l_name
    from bas_carrier
    where car_id=p_car_id;
    return l_name;
  end;
  -----------------------------------------------------------------------------------------------
  function get_carrier_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
    l_param   prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'name_pattern,direction,only_allowed,region_id');
    l_cur     sys_refcursor;
  begin
    open l_cur for
    select
      car_id, 
      decode(car_test, 1, '[TEST] ') || car_name car_name, 
      car_parent_id, 
      have_client_prods,
      have_vendor_prods, 
      car_region_id, 
      car_is_active,
      have_voice_prods, 
      have_sms_prods, 
      have_sms_client_prods,
      have_sms_vendor_prods, 
      car_cc_id
    from bas_carrier
    left join
    (
      select
        acc_car_id,
        max(decode(product_direction, 0, 1)) have_client_prods,
        max(decode(product_direction, 1, 1)) have_vendor_prods,
        max(decode(product_type, prv_var.c_prod_type_int, 1, prv_var.c_prod_type_usdom, 1)) have_voice_prods,
        max(decode(product_type, prv_var.c_prod_type_sms, 1)) have_sms_prods,
        max(case when product_type = prv_var.c_prod_type_sms and product_direction = 0 then 1 end) have_sms_client_prods,
        max(case when product_type = prv_var.c_prod_type_sms and product_direction = 1 then 1 end) have_sms_vendor_prods
      from bas_account a
      inner join bas_product bp on (a.acc_id = product_acc_id)
      group by acc_car_id
    ) on (acc_car_id = car_id)
    where (l_param('name_pattern') is null or car_name like l_param('name_pattern')||'%')
    and
    (
      nullif(to_number(l_param('only_allowed')), 0) is null
      or (l_param('direction') is null and (car_inbound_allowed + car_outbound_allowed) > 0)
      or (l_param('direction') = 0 and car_inbound_allowed = 1)
      or (l_param('direction') = 1 and car_outbound_allowed = 1)
    )
    and
    (
      l_param('direction') is null
      or (to_number(l_param('direction')) = 0 and have_client_prods = 1)
      or (to_number(l_param('direction')) = 1 and have_vendor_prods = 1)
    )
    and
    (
      l_param('region_id') is null
      or car_region_id = to_number(l_param('region_id'))
    )
    order by car_is_active desc, car_name;

    return l_cur;
  end;
  -----------------------------------------------------------------------------------------------
  function get_product_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor 
  is
    l_cur   sys_refcursor;
    l_param prv_utils.param_t;
  begin

    l_param :=
      prv_utils.transform_params
      (
        p_names,p_values,
        'acc_id,car_id,car_name,product_descr,direction,type,first_rec,rec_count,excl_product_ids'
      );

    open l_cur for
    select
      product_id,
      product_descr,
      parent_product_id,
      product_caption,
      product_direction,
      acc_currency_code,
      product_type,
      check_lata,
      rtrim(substr(agr_fields, 1, 64)) agr_timezone_name,
      car_id,
      rates_based_on,
      rate_set_code,
      def_indeterminate_price,
      acc_id,
      car_region_id,
      car_is_active,
      billing_mode,
      to_number(rtrim(substr(agr_fields, 65, 50))) increase_period,
      to_number(rtrim(substr(agr_fields, 115, 50))) decrease_period,
      check_ani_tags,
      (
         select prv_concat_sum(channel_systemid)
         from sms_poi poi
         inner join sms_channel c on (c.channel_id = poi.poi_channel_id)
         where rownum < 100
         and poi.poi_product_id = p.product_id
      ) systemid_list,
      decode(least(car_is_active, is_active), 1, 0, 0, 1) style,
      acc_car_manager_id,
      car_cc_id,
      decode(rownum, 1, cnt) cnt
    from
    (
      select p.*,
        (
          select
            decode
            (
              product_direction, 
              0, 
              rpad(nvl(agr_in_timezone_name, ' '), 64)
                ||rpad(nvl(to_char(agr_in_rate_increase_period), ' '), 50)
                ||rpad(nvl(to_char(agr_in_rate_decrease_period), ' '), 50),
              1, 
              rpad(nvl(agr_out_timezone_name, ' '), 64)
                ||rpad(nvl(to_char(agr_out_rate_increase_period), ' '), 50)
                ||rpad(nvl(to_char(agr_out_rate_decrease_period), ' '), 50)
            )
          from bas_agreement agr
          where agr.agr_acc_id = acc_id
            and agr_start_date <= sysdate
            and agr_end_date > sysdate
            and ((product_direction = 0 and agr_incoming = 1) or (product_direction = 1 and agr_outgoing = 1))
            and rownum = 1
        ) agr_fields,
        count(*) over() cnt,
        row_number() over(order by least(car_is_active, is_active) desc, product_caption) rn
      from bas_product_v p
      where (l_param('acc_id') is null or acc_id = l_param('acc_id'))
        and (l_param('car_id') is null or car_id = l_param('car_id'))
        and (l_param('direction') is null or product_direction = l_param('direction'))
        and (l_param('car_name') is null or lower(product_caption) like replace(lower(l_param('car_name')), '*', '%') || '%')
        and (l_param('product_descr') is null or lower(product_descr) like replace(lower(l_param('product_descr')), '*', '%') || '%')
        and (l_param('excl_product_ids') is null or instr(',' || product_id || ',', ',' || l_param('excl_product_ids') || ',') = 0)
        and
        (
          l_param('type') is null
          or (l_param('type') = 'voip' and product_type in (prv_var.c_prod_type_int, prv_var.c_prod_type_usdom))
          or (l_param('type') = 'sms' and product_type = prv_var.c_prod_type_sms)
          or (l_param('type') = 'international' and product_type = prv_var.c_prod_type_int)
          or (l_param('type') = 'usdomestic' and product_type = prv_var.c_prod_type_usdom)
        )
    ) p
    where rn between nvl(l_param('first_rec'), 1) and nvl(l_param('first_rec') + l_param('rec_count') - 1, 999999);

    return l_cur;

  end;
  -----------------------------------------------------------------------------------------------
  function get_product_descr_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
   l_cur     sys_refcursor;
   l_param   prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'direction,type');
  begin

    open l_cur for
    select
      product_descr,
      max
      (
        case
          when product_type in (prv_var.c_prod_type_int, prv_var.c_prod_type_usdom)
            and product_direction = 0 then
            1
        end
      ) have_voice_client_prods,
      max
      (
        case
          when product_type in (prv_var.c_prod_type_int, prv_var.c_prod_type_usdom)
            and product_direction = 1 then
            1
        end
      ) have_voice_vendor_prods,
      max(case when product_type = prv_var.c_prod_type_sms and product_direction = 0 then 1 end) have_sms_client_prods,
      max(case when product_type = prv_var.c_prod_type_sms and product_direction = 1 then 1 end) have_sms_vendor_prods
    from bas_product
    where (l_param('direction') is null or product_direction = to_number(l_param('direction')))
      and
      (
        l_param('type') is null
        or product_type = prv_var.c_prod_type_sms and l_param('type') = 'sms'
        or product_type != prv_var.c_prod_type_sms and l_param('type') = 'voip'
      )
    group by product_descr
    order by 1;

    return l_cur;

  end;
   -----------------------------------------------------------------------------------------------
  function get_voip_poi_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
    l_cur           sys_refcursor;
    l_param         prv_utils.param_t := 
      prv_utils.transform_params
      (
        p_names,p_values,
        'show_all,direction,car_name,product_descr,poi_name,product_id,first_rec,rec_count,poi_ip,orderby_clause,auth_fields,poi_ids'
      );
    l_poi_ids       prv_number_table_t := prv_utils.str2ntable(l_param('poi_ids'), ',');
    l_poi_ids_cnt   number := l_poi_ids.count;
  begin

    open l_cur for
    select
      voip_poi_id, voip_poi_gw_ip, voip_poi_called_pattern, voip_poi_full_name,
      voip_poi_product_id, voip_poi_trunk_code, voip_poi_switch_id, car_is_active,
      decode(rownum, 1, cnt) cnt
    from
    (
      select 
        p.*,
        car_name||' - '||product_descr || ' (' || a.acc_currency_code || ') - '|| voip_poi_name ||
        (
          select '@'||soft_switch_name from rut_soft_switch where soft_switch_id = voip_poi_switch_id
        ) voip_poi_full_name,
        car_is_active,
        count(*) over() as cnt,
        row_number() over
        (
          order by car_is_active desc,
          decode
          (
            l_param('orderby_clause'),
            'voip_poi_id ASC', lpad(voip_poi_id,38,'0'),
            'voip_poi_gw_ip ASC', voip_poi_gw_ip,
            'voip_poi_called_pattern ASC', voip_poi_called_pattern,
            'voip_poi_priority ASC', lpad(voip_poi_priority,38,'0')
          ),
          decode
          (
            l_param('orderby_clause'),
            'voip_poi_id DESC', lpad(voip_poi_id,38,'0'),
            'voip_poi_gw_ip DESC', voip_poi_gw_ip,
            'voip_poi_called_pattern DESC', voip_poi_called_pattern,
            'voip_poi_priority DESC', lpad(voip_poi_priority,38,'0')
          ) desc
        ) as rn
      from bas_voip_poi p
      inner join bas_product bp on (bp.product_id = p.voip_poi_product_id)
      inner join bas_account a on (a.acc_id = bp.product_acc_id)
      inner join bas_carrier c on (a.acc_car_id = c.car_id)
      where (l_param('product_id') is null or instr(','||l_param('product_id')||',', ','||voip_poi_product_id||',')>0)
      and (l_param('show_all') = 1 or sysdate between voip_poi_dbegin and voip_poi_dend)
      and (l_param('car_name') is null or lower(car_name) like replace(lower(l_param('car_name')),'*','%')||'%')
      and (l_param('product_descr') is null or lower(product_descr) like replace(lower(l_param('product_descr')),'*','%')||'%')
      and 
      (
        l_param('poi_name') is null
        or 
        lower
        (
          voip_poi_name || 
          (
            select '@'||soft_switch_name from rut_soft_switch where soft_switch_id = voip_poi_switch_id
          )
        ) like replace(lower(l_param('poi_name')),'*','%')||'%'
      )
      and (l_param('direction') is null or voip_poi_direction=l_param('direction'))
      and (l_param('poi_ip') is null or voip_poi_gw_ip like l_param('poi_ip')||'%')
      and 
      (
        l_param('auth_fields') is null
        or
        (
          (instr(','||l_param('auth_fields')||',', ',ip,') = 0 or voip_poi_gw_ip is not null)
          and (instr(','||l_param('auth_fields')||',', ',tech_prefix,') = 0 or voip_poi_called_pattern is not null)
          and (instr(','||l_param('auth_fields')||',', ',trunk_code,') = 0 or voip_poi_trunk_code is not null)
          and (instr(','||l_param('auth_fields')||',', ',switch,') = 0 or voip_poi_switch_id is not null)
        )
      )
      and
      (
        l_poi_ids_cnt = 0
        or p.voip_poi_id in (select column_value from table(l_poi_ids))
      )
    )
    where (l_param('first_rec') is null or l_param('rec_count') is null or (rn>=l_param('first_rec') and rn<l_param('first_rec')+l_param('rec_count')))
    order by rn;

    return l_cur;
  end;
   -----------------------------------------------------------------------------------------------
  function get_ip_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
    l_cur     sys_refcursor;
    l_param   prv_utils.param_t := prv_utils.transform_params(p_names,p_values,'direction,first_rec,rec_count,search_mask');
  begin

    open l_cur for
    select voip_poi_gw_ip, decode(rownum, 1, cnt) cnt
    from
    (
      select
        voip_poi_gw_ip,
        count(*) over() as cnt,
        row_number() over(order by voip_poi_gw_ip) as rn
      from
      (
        select distinct voip_poi_gw_ip
        from bas_voip_poi
        where (l_param('direction') is null or voip_poi_direction = l_param('direction'))
        and (l_param('search_mask') is null or voip_poi_gw_ip like replace(l_param('search_mask'),'*','%')||'%')
      )
    )
    where (l_param('first_rec') is null or l_param('rec_count') is null or (rn>=l_param('first_rec') and rn<l_param('first_rec')+l_param('rec_count')))
    order by rn;

    return l_cur;
  end;
  -----------------------------------------------------------------------------------------------
  function get_datetime_fmt_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
    l_param   prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'type');
    l_cur     sys_refcursor;
  begin

    open l_cur for
    select datetime_fmt, datetime_type
    from bas_datetime_fmt
    where (l_param('type') is null or datetime_type = l_param('type'));

    return l_cur;

  end;
  -----------------------------------------------------------------------------------------------
  function get_timezone_list return sys_refcursor
  is
    l_cur sys_refcursor;
  begin

    open l_cur for
    select unique replace(tzname, 'Etc/GMT', 'GMT'),
      prv_utils.get_tz_offset_minutes('GMT', replace(tzname, 'Etc/GMT', 'GMT'), sysdate)/60 offset_from_gmt
    from v$timezone_names
    order by 1;

    return l_cur;
  end;
  -----------------------------------------------------------------------------------------------
  function get_user_menu_item_list return sys_refcursor
  is
    l_cur       sys_refcursor;
    l_user_id   bas_user.user_id%type := get_user_id;
  begin

    open l_cur for
    select
      sys_connect_by_path(menu_item_code,'/') p,
      coalesce(menu_item_type, 'general') type
    from bas_menu m2
    where m2.menu_item_code in
    (
      --Get all parents of granted menus
      select m.menu_item_code
      from bas_menu m
      connect by prior menu_item_parent_item_code = menu_item_code
        start with
        (
          bas_utils.has_role(menu_item_role_code, l_user_id) = 1
          and m.menu_item_role_code in (select column_value from table(get_available_roles))
        )
    )
      and (connect_by_isleaf = 0 or m2.menu_item_role_code is not null)
    connect by prior menu_item_code=menu_item_parent_item_code
      start with menu_item_parent_item_code is null
    order siblings by menu_item_order, prv_utils.get_message(menu_item_code);

    return l_cur;
  end;
  -----------------------------------------------------------------------------------------------
  procedure update_role(p_role_code varchar2, p_parent_role_code varchar2 := '', p_version_bitmap number := 255, p_do_refresh boolean := true)
  is
  begin
    merge into bas_role r
    using dual
    on (r.role_code = p_role_code)
    when matched then update
    set parent_role_code = p_parent_role_code, version_bitmap = p_version_bitmap
    when not matched then insert (role_code, parent_role_code, version_bitmap)
    values (p_role_code, p_parent_role_code, p_version_bitmap);

    if p_do_refresh then
      update_user_roles;
    end if;
  end;
  -----------------------------------------------------------------------------------------------
  procedure delete_role(p_role_code varchar2)
  is
  begin
    delete from bas_user_role where role_code=p_role_code;

    delete from bas_role where role_code=p_role_code;

    update_user_roles;
  end;
  -----------------------------------------------------------------------------------------------
  function get_available_roles return prv_varchar256_table_t
  is
    l_res prv_varchar256_table_t;
  begin

    select role_code
    bulk collect into l_res
    from bas_role r
    where
    (
      version_bitmap = 255
      or (prv_var.c_voice_version = 1 and bitand(1, version_bitmap) > 0)
      or (prv_var.c_sms_version = 1 and bitand(2, version_bitmap) > 0)
      or (prv_var.c_sms_rtl_version = 1 and bitand(4, version_bitmap) > 0)
    );

    return l_res;
  end;
  -----------------------------------------------------------------------------------------------
  --Wrapper
  function get_role_list return sys_refcursor
  is
    l_names dbms_sql.varchar2_table;
    l_values dbms_sql.varchar2_table;
  begin
    return get_role_list(l_names, l_values);
  end;
  -----------------------------------------------------------------------------------------------
  function get_role_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
    l_param prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'root_role_list');
    l_cur   sys_refcursor;
  begin

    if l_param('root_role_list') is null then
      l_param('root_role_list') := 'ROLE-ROOT';
    end if;
    
    open l_cur for
    select role_code,
      role_code_caption,
      parent_role_code
    from
    (
      select r.role_code,
        prv_utils.get_message(r.role_code) role_code_caption,
        r.parent_role_code
      from bas_role r
      where r.role_code in (select column_value from table(bas_utils.get_available_roles))
      connect by prior r.role_code = r.parent_role_code
      --start with r.role_code = 'ROLE-ROOT'
      start with instr(',' || l_param('root_role_list') || ',', ',' || r.role_code || ',') > 0
      order siblings by role_code
    );

    return l_cur;

  end;
  -----------------------------------------------------------------------------------------------
  function get_user_role_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
    l_param           prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'user_id,role_code');
    l_cur             sys_refcursor;
    l_user_id         number := nvl(to_number(l_param('user_id')), get_user_id);
    l_has_root_role   number(1) := has_role('ROLE-ROOT', l_user_id);
  begin

    open l_cur for
    select
      r.role_code,
      prv_utils.get_message(r.role_code) role_code_caption,
      level,
      / * 0 - unchecked, 1 - checked, 2 - role is explicit   * /
      case
        when l_has_root_role = 1 then 2 --User has root rule
        when ur.role_explicit = 1 then 1 --Role explicit
        when ur.role_explicit = 0 then 2 --Role implicit
        when ur.role_code is null then 0
      end checked
    from bas_role r
    left join bas_user_role ur on (ur.role_code = r.role_code and ur.role_user_id = l_user_id)
    where r.role_code in (select column_value from table(bas_utils.get_available_roles))
    connect by prior r.role_code = r.parent_role_code
    start with r.role_code = 'ROLE-ROOT'
    order siblings by role_code;

    return l_cur;

  end;
  -----------------------------------------------------------------------------------------------
  procedure grant_role(p_user_id number, p_role_code varchar2, p_do_implicit_update boolean := true)
  is
  begin
    merge into bas_user_role ur
    using dual
    on (ur.role_user_id = p_user_id and ur.role_code = p_role_code)
    when not matched then
      insert (role_user_id, role_code, role_explicit) values (p_user_id, p_role_code,1)
    when matched then
      update set role_explicit = 1
      where role_explicit != 1;

    prv_var.m_rows_affected := sql%rowcount;

    if p_do_implicit_update and sql%rowcount > 0 then
      update_user_roles(p_user_id);
    end if;
  end;
  -----------------------------------------------------------------------------------------------
  procedure revoke_role(p_user_id number, p_role_code varchar2, p_do_implicit_update boolean := true)
  is
  begin
    delete from bas_user_role
    where role_code = p_role_code
    and role_user_id = p_user_id;

    prv_var.m_rows_affected := sql%rowcount;

    if p_do_implicit_update and sql%rowcount > 0 then
      update_user_roles(p_user_id);
    end if;      
  end;
  -----------------------------------------------------------------------------------------------
  function has_role(p_role_code varchar2, p_user_id number default null) return number
  is
    l_result number;
    l_user_id number := nvl(p_user_id, get_user_id);
  begin

    if p_user_id is null then
      l_result := sys_context('user_ctx', p_role_code);
    end if;

    if l_result is null or p_user_id is not null then
      select count(*)
      into l_result
      from bas_user_role
      where role_code in ('ROLE-ROOT', p_role_code)
      and role_user_id = l_user_id;
    end if;

    if p_user_id is null and l_result > 0 then
      set_context_var(p_role_code, least(l_result, 1));
    end if;

    return least(l_result, 1);
  end;
  -----------------------------------------------------------------------------------------------
  procedure check_role
  (
    p_role_code1 varchar2,
    p_role_code2 varchar2 := null,
    p_role_code3 varchar2 := null,
    p_role_code4 varchar2 := null,
    p_role_code5 varchar2 := null,
    p_user_id number := null
  )
  is
    l_roles_list  varchar2(2048);
    l_roles       prv_varchar30_table_t;
  begin

    l_roles := prv_varchar30_table_t(p_role_code1, p_role_code2, p_role_code3, p_role_code4, p_role_code5);

    if user <> 'INVOICE' then
    
      for i in l_roles.first .. l_roles.last
      loop
        if l_roles(i) is not null and has_role(l_roles(i), p_user_id) = 1 then
          return;
        elsif l_roles(i) is not null then
          l_roles_list := l_roles_list || prv_utils.get_message(l_roles(i)) || ', ';
        end if;
      end loop;

      if coalesce(p_role_code1, p_role_code2, p_role_code3, p_role_code4, p_role_code5) = 'ROLE-ROOT' then
        raise_application_error(-20000, prv_utils.get_message('ERR-NO-SYSOWNER-ROLE'), false);
      else
        raise_application_error(-20000, prv_utils.get_message('ERR-NO-ROLE', rtrim(l_roles_list,', ')), false);
      end if;

    end if;

  end;
  -----------------------------------------------------------------------------------------------
  procedure set_user_cc(p_user_id number, p_cc_array prv_number_table_t) 
  is
  begin

    delete from bas_user_cc
    where user_id = p_user_id
    and cc_id not in (select column_value from table(p_cc_array));
    
    insert into bas_user_cc (user_id, cc_id)
    select p_user_id, column_value
    from table(p_cc_array)
    where (p_user_id, column_value) not in (select user_id, cc_id from bas_user_cc);

  end;
  -----------------------------------------------------------------------------------------------
  procedure set_user_roles(p_user_id number, p_role_array prv_varchar4000_table_t) is
    l_roles_to_grant      dbms_sql.varchar2_table;
    l_roles_to_revoke     dbms_sql.varchar2_table;
    l_do_implicit_update  boolean := false;
    l_grantee_car_id      number;
    --
    procedure raise_error(p_role_code varchar2) is
    begin
      raise_application_error
      (
        -20000,
        prv_utils.get_message('ERR-CANNOT_GRANT_THIS_ROLE', prv_utils.get_message(p_role_code))
      );
    end;
    --
  begin
    
    select user_car_id 
    into l_grantee_car_id
    from bas_user
    where user_id = p_user_id;
    
    if l_grantee_car_id = 1 then
      if not (user = 'INVOICE' or bas_utils.has_role('ROLE-VPD-FULL', bas_utils.get_user_id) = 1) then
        raise_application_error
        (
          -20000, 
          prv_utils.get_message
          (
            'ERR-NO-RIGHT-TO-GRANT-ROLE-TO-SYSOWN-USER',
            prv_utils.get_message('ROLE-VPD-FULL')
          )
        );
      end if;
    end if;
    
    select column_value
    bulk collect into l_roles_to_grant
    from table(p_role_array)
    where column_value not in 
    (
      select ur.role_code 
      from bas_user_role ur
      where ur.role_user_id = p_user_id 
      and ur.role_explicit = 1
    );
    
    select ur.role_code
    bulk collect into l_roles_to_revoke
    from bas_user_role ur
    where ur.role_user_id = p_user_id
    and ur.role_explicit = 1
    and ur.role_code not in
    (
      select column_value
      from table(p_role_array)
      where column_value is not null
    );
    

    if l_roles_to_grant.count > 0 then
      
      check_role('ROLE-ADMIN-USER');
      
      for i in l_roles_to_grant.first..l_roles_to_grant.last loop
      
        if bas_utils.has_role(l_roles_to_grant(i), bas_utils.get_user_id) = 0 then

          raise_error(l_roles_to_grant(i));

        else
        
          grant_role(p_user_id, l_roles_to_grant(i), false);
        
        end if;
      
      end loop;
      
      l_do_implicit_update := true;

    end if;
      
    if l_roles_to_revoke.count > 0 then
      
      check_role('ROLE-ADMIN-USER');
      
      for i in l_roles_to_revoke.first..l_roles_to_revoke.last loop
      
        if bas_utils.has_role(l_roles_to_revoke(i), bas_utils.get_user_id) = 0 then

          raise_error(l_roles_to_revoke(i));

        else
        
          revoke_role(p_user_id, l_roles_to_revoke(i), false);
        
        end if;
      
      end loop;
      
      l_do_implicit_update := true;

    end if;
  
    if l_do_implicit_update then
      update_user_roles(p_user_id);
    end if;

  end;
  -----------------------------------------------------------------------------------------------
  procedure set_parent_users(p_user_id number, p_parent_user_ids prv_number_table_t) 
  is
    l_change_cnt       number;
    l_cycle_cnt        number := 0;
    l_grantee_car_id   number;
    l_non_sys_own_cnt  number;
    
  begin
  
    select count(*)
    into l_change_cnt
    from
    (
      select parent_user_id from bas_user_hierarchy where user_id = p_user_id
      union
      select column_value from table (p_parent_user_ids)
    )
    minus
    (
      select parent_user_id from bas_user_hierarchy where user_id = p_user_id
      intersect
      select column_value from table (p_parent_user_ids)
    );
    
    if l_change_cnt > 0 then
      
      check_role('ROLE-ADMIN-USER');
      
      if not (user = 'INVOICE' or bas_utils.has_role('ROLE-VPD-FULL', bas_utils.get_user_id) = 1) then
        raise_application_error
        (
          -20000, 
          prv_utils.get_message
          (
            'ERR-NO-RIGHT-TO-ASSIGN-PARENT-USER',
            prv_utils.get_message('ROLE-VPD-FULL')
          )
        );
      end if;
      
      select user_car_id 
      into l_grantee_car_id
      from bas_user
      where user_id = p_user_id;
      
      if l_grantee_car_id <> 1 then
        raise_application_error(-20000, prv_utils.get_message('ERR-ROLE-INHERITANCE-NOT-AVAIL'));
      end if;
      
      select count(*)
      into l_non_sys_own_cnt
      from bas_user
      where user_id in (select column_value from table(p_parent_user_ids))
      and user_car_id <> 1;
      
      if l_non_sys_own_cnt > 0 then
        raise_application_error(-20000, prv_utils.get_message('ERR-CANNOT-INHERIT-FROM-NON-SYSOWN'));
      end if;
      
      delete from bas_user_hierarchy
      where user_id = p_user_id
      and parent_user_id not in (select column_value from table(p_parent_user_ids));
      
      insert into bas_user_hierarchy (user_id, parent_user_id)
      select p_user_id, column_value
      from table(p_parent_user_ids)
      where (p_user_id, column_value) not in (select user_id, parent_user_id from bas_user_hierarchy);
      
      select count(*)
      into l_cycle_cnt
      from
      (
        select connect_by_iscycle is_cycle
        from bas_user_hierarchy
        connect by nocycle user_id = prior parent_user_id
        order siblings by user_id
      )
      where is_cycle = 1;
      
      if l_cycle_cnt > 0 then
        raise_application_error(-20000, prv_utils.get_message('ERR-CYCLE-IN-USER-HIERARCHY'));
      end if;
      
      update_user_roles;
      
    end if;

  end;
  -----------------------------------------------------------------------------------------------
  procedure update_user_roles(p_user_id number default null)
  is
  
  begin
    
    delete from bas_user_role
    where role_explicit = 0
    and role_user_id not in (select user_id from bas_user where user_car_id = 1)
    and (role_user_id = p_user_id or p_user_id is null);
    
    merge into bas_user_role t
    using
    (
      select
        role_code,
        max(role_explicit) role_explicit,
        role_user_id
      from
      (
        select user_id
        from bas_user
        where user_car_id <> 1
        and (user_id = p_user_id or p_user_id is null)
      ) u
      left join 
      (
        select 
          r.role_user_id,
          rh.role_code,
          max(is_explicit) role_explicit
        from bas_user_role r
        left join bas_role_hierarchy_v rh on r.role_code = rh.root_role
        where r.role_explicit = 1
        group by r.role_user_id, rh.role_code
      ) ur
      on u.user_id = ur.role_user_id
      where ur.role_code is not null
      group by role_user_id, role_code
    ) s
    on (t.role_code = s.role_code and t.role_user_id = s.role_user_id)
    when not matched then 
    insert (t.role_code, t.role_explicit, t.role_user_id) values (s.role_code, s.role_explicit, s.role_user_id);
    
    if user = 'INVOICE' or bas_utils.has_role('ROLE-VPD-FULL', bas_utils.get_user_id) = 1 then
      
      delete from bas_user_role
      where role_explicit = 0
      and role_user_id in (select user_id from bas_user where user_car_id = 1);
      
      merge into bas_user_role t
      using
      (
        select 
          role_code,
          max(case lvl when 1 then role_explicit else 0 end) role_explicit,
          child_user_id role_user_id
          --min(case lvl when 1 then 0 else 1 end) role_inherited
        from
        (
          select 
            sys_connect_by_path(u.user_id,'/') upath,
            connect_by_isleaf,
            connect_by_root u.user_id child_user_id,
            prior u.user_id,
            u.user_id,
            level lvl
          from bas_user u
          left join bas_user_hierarchy h on u.user_id = h.user_id
          where user_car_id = 1
          connect by u.user_id = prior parent_user_id
          order siblings by u.user_id
        ) uh
        left join 
        (
          select 
            r.role_user_id,
            rh.role_code,
            max(is_explicit) role_explicit
          from bas_user_role r
          left join bas_role_hierarchy_v rh on r.role_code = rh.root_role
          where r.role_explicit = 1
          group by r.role_user_id, rh.role_code
        ) ur
        on uh.user_id = ur.role_user_id
        where ur.role_code is not null
        group by child_user_id, role_code
      ) s
      on (t.role_code = s.role_code and t.role_user_id = s.role_user_id)
      when not matched then 
      insert (t.role_code, t.role_explicit, t.role_user_id) values (s.role_code, s.role_explicit, s.role_user_id);
      
    end if;
    
  end;
  -----------------------------------------------------------------------------------------------
  procedure fix_dial_code
  is
  begin

    insert into bas_dial_code (dial_code, dial_code_country, dial_code_region, dial_code_type)
    select
      rate_dial_code, nvl(ltrim(substr(destination, 1, 256)), 'Undefined'), ltrim(substr(destination, 257, 256)),
      nvl(ltrim(substr(destination, 513, 256)), 'Undefined')
    from
    (
      select
        rate_dial_code,
        (
          select
            max(lpad(dial_code_country,256)
            || lpad(nvl(dial_code_region,' '),256)
            || lpad(dial_code_type,256)) keep (dense_rank first order by length(dial_code) desc)
          from bas_dial_code
          where dial_code in
            (
              substr(rate_dial_code,1,1), substr(rate_dial_code,1,2), substr(rate_dial_code,1,3), substr(rate_dial_code,1,4),
              substr(rate_dial_code,1,5), substr(rate_dial_code,1,6), substr(rate_dial_code,1,7), substr(rate_dial_code,1,8),
              substr(rate_dial_code,1,9), substr(rate_dial_code,1,10), substr(rate_dial_code,1,11), substr(rate_dial_code,1,12),
              substr(rate_dial_code,1,13), substr(rate_dial_code,1,14), substr(rate_dial_code,1,15), substr(rate_dial_code,1,16)
            )
        ) destination
      from
      (
        select distinct rate_dial_code
        from rat_rate
        where rate_dial_code not in (select dial_code from bas_dial_code)
      )
    );

  end;
  -----------------------------------------------------------------------------------------------
  procedure fix_types
  is
  begin
    --Fix types
    insert into bas_dial_code_type (type_name, type_id)
    select dial_code_type, bas_dial_code_type_id_seq.nextval
    from
    (
      select dial_code_type
      from bas_dial_code
      union
      select new_dial_code_type
      from bas_dial_code_pending
    )
    where dial_code_type not in (select type_name from bas_dial_code_type);
  end;
  -----------------------------------------------------------------------------------------------
  procedure fix_countries
  is
  begin
    --Fix countries
    insert into bas_dial_code_country (country_name, country_id)
    select dial_code_country, bas_dial_code_country_id_seq.nextval
    from
    (
      select dial_code_country
      from bas_dial_code
      union
      select new_dial_code_country
      from bas_dial_code_pending
    )
    where dial_code_country not in (select country_name from bas_dial_code_country);
  end;
  ----------------------------------------------------------------------------------------------------------------------
  procedure fix_country_code(p_dial_code varchar2 := null)
  is
  begin
    
    insert into bas_country_code (record_id, country, country_dial_code)
    select bas_country_code_id_seq.nextval record_id, dial_code_country country, dial_code country_dial_code
    from
    (
      select dial_code_country, dial_code,
        min(length(dial_code)) over (partition by dial_code_country) min_length
      from bas_dial_code
      where (p_dial_code is null or dial_code = p_dial_code)
    )
    where length(dial_code) = min_length
    and dial_code not in (select t.country_dial_code from bas_country_code t);

  end;
  ----------------------------------------------------------------------------------------------------------------------
  function import_data_from_file(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return varchar2 --wrapper for new api
  is
    l_param     prv_utils.param_t;
    l_message   varchar2(4000);
  begin
    l_param := prv_utils.transform_params(p_names, p_values, 'table_name,filename,separator,skip_cnt,clear_before_load');
    l_param('separator') := nvl(l_param('separator'), ';');
    l_param('skip_cnt') := nvl(l_param('skip_cnt'), '0');
    l_param('clear_before_load') := nvl(l_param('clear_before_load'), '1');

    l_message :=
      import_data_from_file
      (
        l_param('table_name'),
        l_param('filename'),
        l_param('separator'),
        to_number(l_param('skip_cnt')),
        to_number(l_param('clear_before_load'))
      );
    return l_message;
  end;
  ----------------------------------------------------------------------------------------------------------------------
  function import_data_from_file
  (
    p_table_name          varchar2,
    p_filename            varchar2,
    p_separator           char default ';',
    p_skip_cnt            number default 0,
    p_clear_before_load   number default 1
  )
  return varchar2
  is
    l_debug             varchar2(4000);
    l_task_start_time   timestamp(3) := systimestamp;
    l_affected_row_cnt  number := 0;
    c_nl                varchar2(2) := chr(13)||chr(10);
  begin

    if p_table_name = 'BAS_LRG6' then
      --lgr6 import

      execute immediate 'alter table bas_imp_lrg6_ext
        location ('''||p_filename||''')
        access parameters
        (
          records delimited by newline
          skip '||p_skip_cnt||'
          fields terminated by '''||p_separator||'''
          optionally enclosed by ''"''
          missing field values are null
        )';

      if p_clear_before_load = 1 then
        delete from bas_lrg6;
      end if;

      insert into bas_lrg6 (lata, status, eff_date, npa, nxx, block_id, ocn, loc_state, prefix_type)
      select distinct lata, status, to_date(eff_date, 'MMDDYY'), npa, nxx, nvl(block_id, 'A'), nvl(ocn, '0'), loc_state, prefix_type
      from bas_imp_lrg6_ext;

      l_affected_row_cnt := sql%rowcount;
    else
      --Common import
      execute immediate 'alter table bas_imp_common_ext
        location ('''||p_filename||''')
        access parameters
          (
            records delimited by newline
            skip '||p_skip_cnt||'
            fields terminated by '''||p_separator||'''
            optionally enclosed by ''"''
            missing field values are null
          )';

      case p_table_name
      when 'BAS_DIAL_CODE'
      then

        if p_clear_before_load = 1 then

          delete from bas_dial_code;
          delete from bas_dial_code_country;
          delete from bas_dial_code_type;

        else

          delete from bas_dial_code
          where rowid in
          (
            with q as
            (
              select 
                d2.dial_code, 
                d2.dial_code_destination
              from bas_dial_code d2
              where d2.dial_code in
              (
                select trim(e.col01)
                from bas_imp_common_ext e
                where regexp_like(trim(e.col01), '^[0-9]+$')
                and trim(e.col02) is not null
                and trim(e.col04) is not null
              )
            )
            select d1.rowid
            from bas_dial_code d1
            where d1.dial_code in (select q.dial_code from q) --Such dial code presents in file
            or exists
            (
              select 1
              from q
              where d1.dial_code like q.dial_code || '_%'
              and d1.dial_code_destination = q.dial_code_destination
            )
          );

        end if;

        --Load dial codes
        insert into bas_dial_code (dial_code, dial_code_country, dial_code_region, dial_code_type)
        select distinct trim(col01), trim(col02), trim(col03), trim(rtrim(col04,c_nl))
        from bas_imp_common_ext
        where regexp_like(trim(col01), '^[0-9]+$')
        and trim(col02) is not null
        and trim(col04) is not null
        and trim(col01) not in (select t.dial_code from bas_dial_code t);

        l_affected_row_cnt := sql%rowcount;

        fix_dial_code;
        fix_countries;
        fix_types;
        fix_country_code;

      when 'BAS_DIAL_CODE_COUNTRY'
      then
        if p_clear_before_load = 1 then
          delete from bas_dial_code_country;
        end if;

        insert into bas_dial_code_country (country_name, country_id)
        select dial_code_country, bas_dial_code_country_id_seq.nextval
        from
        (
          select distinct trim(rtrim(col01,c_nl)) dial_code_country
          from bas_imp_common_ext
        )
        where dial_code_country not in (select country_name from bas_dial_code_country)
        and dial_code_country is not null;

        l_affected_row_cnt := sql%rowcount;

        fix_countries;

      when 'BAS_DIAL_CODE_TYPE'
      then
        if p_clear_before_load = 1 then
          delete from bas_dial_code_type;
        end if;

        insert into bas_dial_code_type (type_name, type_id)
        select dial_code_type, bas_dial_code_type_id_seq.nextval
        from
        (
          select distinct trim(rtrim(col01,c_nl)) dial_code_type
          from bas_imp_common_ext
        )
        where dial_code_type not in (select type_name from bas_dial_code_type)
        and dial_code_type is not null;

        l_affected_row_cnt := sql%rowcount;

        fix_types;

      end case;

    end if;

    if l_affected_row_cnt = 0 and p_clear_before_load = 1 then
      rollback;
    else
      commit;
    end if;

    l_debug := l_debug || 'processed rows='||l_affected_row_cnt||'; ';
    l_debug := l_debug || 'spend time='||to_char(extract(second from systimestamp-l_task_start_time),'990.099')||' sec.; ';
    l_debug := l_debug || 'filename='||p_filename||'; ';

    prv_utils.save_debug('Data import', l_debug);

     --Clean up after successful loading
    utl_file.fremove(c_file_directory,p_filename);

    return prv_utils.get_message('BAS-IMPORT-SUCCESSFUL', nvl(l_affected_row_cnt,0));

    exception
      when others then
        prv_utils.save_debug
        (
          'Data import',
          'Error:' || ': ' || dbms_utility.format_error_stack() || chr(13) || chr(10) ||
          dbms_utility.format_error_backtrace() || chr(13) || chr(10),
          prv_utils.c_debug_error
        );
      rollback;
      utl_file.fremove(c_file_directory,p_filename);
      return prv_utils.get_message('BAS-INVALID-FILE-FORMAT', prv_utils.translate_error_msg(dbms_utility.format_error_stack()));
  end;
  -----------------------------------------------------------------------------------------------
  function get_template_type_list return sys_refcursor
  is
    l_cur sys_refcursor;
  begin
    open l_cur for
    select template_type_id, prv_utils.get_message(template_type_id) template_type_name, template_format
    from bas_template_type
    order by prv_utils.get_message(template_type_id);
    
    return l_cur;
  end;
  -----------------------------------------------------------------------------------------------
  function get_template_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
    l_param prv_utils.param_t :=
      prv_utils.transform_params
      (
        p_names, 
        p_values, 
        'template_type_id,template_cc_id,template_acc_id,template_descr'
      );
    l_cur sys_refcursor;
  begin

    open l_cur for
    select
      template_id,
      template_type_id,
      nvl2
      (
        template_acc_ids,
        (
          select 
            listagg(car_name || ' (' || acc_currency_code || ')', ', ') within group (order by car_name)
          from bas_carrier c
          inner join bas_account a on (a.acc_car_id = c.car_id)
          where instr(',' || template_acc_ids || ',', ',' || a.acc_id || ',') > 0
            and rownum < 100),
        'Default'
      ) template_name,
      template_last_updated,
      template_acc_ids,
      template_ext_info,
      template_cc_id,
      template_content_type,
      template_product_type_ids,
      template_descr,
      template_product_ids,
      case
        when coalesce
        (
          template_acc_ids,
          to_char(template_cc_id), 
          template_product_type_ids, 
          template_product_ids
        ) is null then
          1
        else 
          null
        end template_is_default
    from bas_template t
    where (l_param('template_type_id') is null or template_type_id = l_param('template_type_id'))
    and (l_param('template_descr') is null or lower(template_descr) like lower(replace(l_param('template_descr'), '*', '%')) || '%')
    and (l_param('template_cc_id') is null or template_cc_id is null or template_cc_id = l_param('template_cc_id'))
    and 
    (
      l_param('template_acc_id') is null 
      or template_acc_ids is null 
      or instr(',' || template_acc_ids || ',', ',' || l_param('template_acc_id') || ',') > 0
    )
    order by prv_utils.get_message(template_type_id), nvl2(template_acc_ids, 2, 1), template_id;

    return l_cur;

  end;
  -----------------------------------------------------------------------------------------------
  procedure update_template
  (
    p_names         dbms_sql.varchar2_table,
    p_values        dbms_sql.varchar2_table,
    p_content_blob  blob
  )
  is
    l_param prv_utils.param_t :=
      prv_utils.transform_params
      (
        p_names,p_values,
        'template_id,template_type,template_acc_ids,template_ext_info,template_file_name,template_cc_id,'||
        'template_product_type_ids,template_descr,template_product_ids'
      );
    l_file_postfix  varchar2(4000);
    l_content_type  bas_template.template_content_type%type;
    l_handler       bas_template.template_handler%type;
    
  begin
    
    if l_param('template_cc_id') is not null and l_param('template_acc_ids') is not null then
      for i in 
      (
        select acc_ids
        from
        (
          select listagg(acc_id, ', ') within group (order by 1) acc_ids
          from bas_account 
          inner join bas_carrier on acc_car_id = car_id
          where acc_id in (select * from table(prv_utils.str2ntable(l_param('template_acc_ids'), ',')))
          and car_cc_id <> to_number(l_param('template_cc_id'))
        )
        where acc_ids is not null
      )
      loop
        raise_application_error
        (
          -20000,
          prv_utils.get_message('ERR-TEMPLATE-WRONG-ACC-CC', i.acc_ids)
        );
      end loop;
    end if;
    
    for i in
    (    
      select
        case 
          when template_type_id = c_inv_det_template_type then 
            1
          when template_type_id in ('RAT-EXP','RAT-EXP-LETTER','SMS-RAT-EXP','SMS-RAT-EXP-LETTER') then
            2
          else 
            0 
        end pt_check,
        template_id,
        nvl
        (
          prv_utils.table2str
          (
            prv_utils.str2ntable(template_cc_id, ',')
            multiset intersect
            prv_utils.str2ntable(l_param('template_cc_id'), ','),
            ', '
          ),
          prv_utils.get_message('UI-All')
        ) int_cc_ids,
        nvl
        (
          prv_utils.table2str
          (
            prv_utils.str2ntable(template_acc_ids, ',')
            multiset intersect
            prv_utils.str2ntable(l_param('template_acc_ids'), ','),
            ', '
          ),
          prv_utils.get_message('UI-Default')
        ) int_acc_ids,
        nvl
        (
          (
            select listagg(product_type_name, ', ') within group (order by 1) 
            from table
            (
              prv_utils.str2ntable(template_product_type_ids, ',')
              multiset intersect
              prv_utils.str2ntable(l_param('template_product_type_ids'), ',')
            )
            inner join bas_product_type on column_value = product_type_id
          ),
          prv_utils.get_message('UI-All')
        ) int_pt,
        nvl
        (  
          prv_utils.table2str
          (
            prv_utils.str2ntable(template_product_ids, ',')
            multiset intersect
            prv_utils.str2ntable(l_param('template_product_ids'), ','),
            ', '
          ),
          prv_utils.get_message('UI-All')
        )  int_product_name
      from bas_template t
      where template_type_id = l_param('template_type')
      and (l_param('template_id') is null or l_param('template_id') <> template_id)
      and
      (
        (
          prv_utils.str2ntable(template_cc_id, ',') = prv_utils.str2ntable(l_param('template_cc_id'), ',')
          or
          prv_utils.str2ntable(template_cc_id, ',')
          multiset intersect
          prv_utils.str2ntable(l_param('template_cc_id'), ',')
          is not empty
        )
        and
        (
          prv_utils.str2ntable(template_acc_ids, ',') = prv_utils.str2ntable(l_param('template_acc_ids'), ',')
          or
          prv_utils.str2ntable(template_acc_ids, ',')
          multiset intersect
          prv_utils.str2ntable(l_param('template_acc_ids'), ',')
          is not empty
        )
        and 
        (
          template_type_id <> c_inv_det_template_type
          or
          (
            prv_utils.str2ntable(template_product_type_ids, ',') = prv_utils.str2ntable(l_param('template_product_type_ids'), ',')
            or
            prv_utils.str2ntable(template_product_type_ids, ',')
            multiset intersect
            prv_utils.str2ntable(l_param('template_product_type_ids'), ',')
            is not empty
          )
        )
        and
        (
          template_type_id not in ('RAT-EXP','RAT-EXP-LETTER','SMS-RAT-EXP','SMS-RAT-EXP-LETTER')
          or
          (
            prv_utils.str2ntable(template_product_ids, ',') = prv_utils.str2ntable(l_param('template_product_ids'), ',')
            or
            prv_utils.str2ntable(template_product_ids, ',')
            multiset intersect
            prv_utils.str2ntable(l_param('template_product_ids'), ',')
            is not empty
          )
        )
      )
    )
    loop
      raise_application_error
      (
        -20000,
        prv_utils.get_message
        (
          case i.pt_check
            when 0 then 'ERR-TEMPLATE-EXISTS-1'
            when 1 then 'ERR-TEMPLATE-EXISTS-2'
            when 2 then 'ERR-TEMPLATE-EXISTS-3'
          end,
          i.template_id,
          i.int_cc_ids,
          i.int_acc_ids,
          i.int_pt,
          i.int_product_name
        )
      );
    end loop;
    
    l_file_postfix := substr(l_param('template_file_name'), instr(l_param('template_file_name'), '.', -1) + 1);

    -- set content_type
    select
      case t.template_format
        when bas_utils.c_tmpl_type_mail then bas_utils.c_tmpl_cont_mail
        when bas_utils.c_tmpl_type_file then l_file_postfix
      end
    into l_content_type
    from bas_template_type t
    where t.template_type_id = l_param('template_type');

    -- set handler
    l_handler :=
      case l_content_type
        when bas_utils.c_tmpl_cont_xlsx then bas_utils.c_tmpl_hand_docproc
        when bas_utils.c_tmpl_cont_xls then bas_utils.c_tmpl_hand_embed_poi
      end;

    if l_content_type = bas_utils.c_tmpl_cont_mail and dbms_lob.getlength(p_content_blob) > 32767 then
      raise_application_error(-20000, prv_utils.get_message('ERR-HTML_TEMPLATE_TOO_LARGE'));
    end if;

    if dbms_lob.getlength(p_content_blob) = 0 then
      raise_application_error(-20000, prv_utils.get_message('ERR-IMP_EMPTY_TEMPLATE'));
    elsif l_param('template_id') is null then
      insert into bas_template
      (
        template_id,
        template_type_id,
        template_blob,
        template_last_updated,
        template_acc_ids,
        template_ext_info,
        template_cc_id,
        template_handler,
        template_content_type,
        template_product_type_ids,
        template_descr,
        template_product_ids
      )
      values
      (
        bas_template_id_seq.nextval,
        l_param('template_type'),
        p_content_blob,
        sysdate,
        l_param('template_acc_ids'),
        l_param('template_ext_info'),
        l_param('template_cc_id'),
        l_handler,
        l_content_type,
        l_param('template_product_type_ids'),
        l_param('template_descr'),
        l_param('template_product_ids')
      );
    else
      update bas_template set
        template_blob = nvl(p_content_blob, template_blob),
        template_last_updated = sysdate,
        template_acc_ids = l_param('template_acc_ids'),
        template_ext_info = l_param('template_ext_info'),
        template_cc_id = l_param('template_cc_id'),
        template_handler = coalesce(l_handler,template_handler),
        template_content_type = coalesce(l_content_type, template_content_type),
        template_product_type_ids = l_param('template_product_type_ids'),
        template_descr = l_param('template_descr'),
        template_product_ids = l_param('template_product_ids')
      where template_id = l_param('template_id');
    end if;
  end;
  -----------------------------------------------------------------------------------------------
  function get_template_blob
  (
    p_template_type varchar2,
    p_template_acc_id number,
    p_template_cc_id number := null,
    p_template_content_type varchar2 := null,
    p_template_product_type number default null,
    p_template_product_id number default null
  )
  return blob
  is
  begin  
    return get_template_rec
    (
      p_template_type => p_template_type,
      p_template_acc_id => p_template_acc_id,
      p_templace_cc_id => p_template_cc_id,
      p_template_content_type => p_template_content_type,
      p_template_product_type => p_template_product_type,
      p_template_product_id => p_template_product_id
    ).template_blob;
  end;
  -----------------------------------------------------------------------------------------------
  function get_template_rec
  (
    p_template_type varchar2,
    p_template_acc_id number,
    p_templace_cc_id number := null,
    p_template_content_type  varchar2 := null,
    p_template_product_type  number default null,
    p_template_product_id number default null
  ) return bas_template%rowtype
  is
    l_rec            bas_template%rowtype;
    l_template_cc_id number := nvl(p_templace_cc_id, get_account_cc(p_template_acc_id));
  begin

    select *
    into l_rec
    from bas_template
    where template_type_id = p_template_type
    and template_id =
    (
      select 
        max(t.template_id) keep 
        (
          dense_rank first
          order by 
          t.template_product_ids nulls last,
          t.template_product_type_ids nulls last,
          t.template_acc_ids nulls last,
          t.template_cc_id nulls last
        )
      from bas_template t
      where template_type_id = p_template_type
      and
      (
        instr(',' || t.template_acc_ids || ',', ',' || p_template_acc_id || ',') > 0
        or t.template_acc_ids is null
      )
      and
      (
        nvl(t.template_cc_id, -1) = nvl(l_template_cc_id, -1)
        or t.template_cc_id is null
      )
      and
      (
        p_template_content_type is null
        or t.template_content_type = p_template_content_type
      )
      and
      (
        instr(',' || t.template_product_type_ids || ',', ',' || p_template_product_type || ',') > 0
        or t.template_product_type_ids is null
      )
      and
      (
        instr(',' || t.template_product_ids || ',', ',' || p_template_product_id || ',') > 0
        or t.template_product_ids is null
      )
    )
    and dbms_lob.getlength(template_blob) > 0;

    return l_rec;

    exception

      when no_data_found then
        raise_application_error
        (
          -20000,
          prv_utils.get_message('BAS-ERR-DOC-GEN-FAIL-NO-TEMPLATE', prv_utils.get_message(p_template_type))
        );

  end;
  -----------------------------------------------------------------------------------------------
  function get_template_ext_info
  (
    p_template_type varchar2,
    p_template_acc_id number,
    p_template_cc_id number := null,
    p_template_content_type varchar2 := null,
    p_template_product_type  number default null,
    p_template_product_id number default null
  )
  return varchar2
  is
  begin
    return get_template_rec
    (
      p_template_type,
      p_template_acc_id,
      p_template_cc_id,
      p_template_content_type,
      p_template_product_type,
      p_template_product_id
    ).template_ext_info;
  end;
  -----------------------------------------------------------------------------------------------
  function get_template_content --new api
  (
    p_names       dbms_sql.varchar2_table,
    p_values      dbms_sql.varchar2_table,
    p_filename    out varchar2
  )
  return blob
  is
    l_param   prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'template_id,format');
    l_blob    blob;
    
    l_extension_file varchar2(16);
  begin
    
    if l_param('format') is null then
      l_param('format') := 'xls';
    end if;

    select 
      t.template_blob, 
      t.template_content_type,
      prv_utils.get_message(t.template_type_id)||'.'||l_param('format')
    into 
      l_blob, 
      l_extension_file,
      p_filename
    from bas_template t
    where template_id = to_number(l_param('template_id'));

    if l_param('format') = 'pdf' then
      l_blob := prv_exp_utils.xls2pdf(l_blob,l_extension_file);
    end if;

    return l_blob;
  end;
  -----------------------------------------------------------------------------------------------
  function get_template_content --old api. ready to delete
  (
    p_template_id   number,
    p_format        varchar2 default 'xls',
    p_filename      out varchar2
  )
  return blob
  is
    l_blob blob;
    l_extension_file varchar2(16);
  begin

    select 
      t.template_blob, 
      t.template_content_type,
      prv_utils.get_message(t.template_type_id)||'.'||p_format
    into 
      l_blob, 
      l_extension_file,
      p_filename
    from bas_template t
    where template_id = p_template_id;

    if p_format = 'pdf' then
      l_blob := prv_exp_utils.xls2pdf(l_blob,l_extension_file);
    end if;

    return l_blob;
  end;
  -----------------------------------------------------------------------
  procedure delete_template(p_template_id number)
  is
    l_template_acc_ids       bas_template.template_acc_ids%type;
    l_template_cc_id         bas_template.template_cc_id%type;
    l_template_product_typ_ids  bas_template.template_product_type_ids%type;
    l_template_product_ids  bas_template.template_product_ids%type;
  begin
  
    delete from bas_template
    where template_id = p_template_id
    returning 
      template_acc_ids, template_cc_id, template_product_type_ids, template_product_ids
    into 
      l_template_acc_ids, l_template_cc_id, l_template_product_typ_ids, l_template_product_ids;

    if coalesce(l_template_acc_ids, to_char(l_template_cc_id), l_template_product_typ_ids, l_template_product_ids) is null  then
      raise_application_error(-20000, prv_utils.get_message('ERR-CANNOT_DELEDE_DEFAULT_TEMPLATE'));
    end if;
  end;
  ---------------------------------------------------------------------------------------------------------------------
  function get_region_list return sys_refcursor is
    l_cur sys_refcursor;
  begin
    open l_cur for
    select region_id, region_name, region_manager_user_id
    from bas_region
    order by 2;
    return l_cur;
  end;
  -----------------------------------------------------------------------
  procedure update_region(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) is
    l_param prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'region_id,name,manager_user_id');
  begin

    if l_param('region_id') is null then
      insert into bas_region (region_id, region_name, region_manager_user_id)
      values (bas_region_id_seq.nextval, l_param('name'), l_param('manager_user_id'));
    else
      update bas_region set
        region_name = l_param('name'),
        region_manager_user_id = l_param('manager_user_id')
      where region_id = l_param('region_id');
    end if;
  end;
  -----------------------------------------------------------------------
  procedure delete_region(p_region_id number) is
  begin
    delete from bas_region
    where region_id = p_region_id;
  end;
  -----------------------------------------------------------------------
  function get_bank_account_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
    l_param prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'bacc_id,active_at,car_id');
    l_cur   sys_refcursor;
  begin

    open l_cur for
    select
        bacc_id,
        bacc_bank_name,
        bacc_recipient_name,
        bacc_cc_id,
        bacc_account,
        bacc_currency_code,
        bacc_swift_code,
        bacc_corr_accounts,
        bacc_start_date,
        bacc_end_date,
        bacc_comments
    from bas_bank_account a
    where (l_param('bacc_id') is null or bacc_id = l_param('bacc_id'))
      and
      (
        l_param('car_id') is null
        or a.bacc_cc_id in (select car_cc_id from bas_carrier where car_id = l_param('car_id'))
      )
      and
      (
        l_param('active_at') is null or
        to_date(l_param('active_at'), prv_var.c_sys_datetime_fmt) between bacc_start_date and bacc_end_date
      )
    order by bacc_bank_name, bacc_account;

    return l_cur;

  end;
  -----------------------------------------------------------------------
  procedure update_bank_account(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table)
  is
    l_param prv_utils.param_t;
  begin

    l_param :=
      prv_utils.transform_params
      (
        p_names,
        p_values,
        'bacc_id,bacc_bank_name,bacc_recipient_name,bacc_cc_id,bacc_account,bacc_currency_code,bacc_swift_code,'
        || 'bacc_corr_accounts,bacc_start_date,bacc_end_date,bacc_comments'
      );

    if l_param('bacc_id') is null then
      insert into bas_bank_account
      (
        bacc_id,
        bacc_bank_name,
        bacc_recipient_name,
        bacc_cc_id,
        bacc_account,
        bacc_currency_code,
        bacc_swift_code,
        bacc_corr_accounts,
        bacc_start_date,
        bacc_end_date,
        bacc_comments
      )
      values
      (
        bacc_id_seq.nextval,
        l_param('bacc_bank_name'),
        l_param('bacc_recipient_name'),
        l_param('bacc_cc_id'),
        l_param('bacc_account'),
        l_param('bacc_currency_code'),
        l_param('bacc_swift_code'),
        l_param('bacc_corr_accounts'),
        l_param('bacc_start_date'),
        l_param('bacc_end_date'),
        l_param('bacc_comments')
      );
    else
      update bas_bank_account
      set
        bacc_bank_name = l_param('bacc_bank_name'),
        bacc_recipient_name = l_param('bacc_recipient_name'),
        bacc_cc_id = l_param('bacc_cc_id'),
        bacc_account = l_param('bacc_account'),
        bacc_currency_code = l_param('bacc_currency_code'),
        bacc_swift_code = l_param('bacc_swift_code'),
        bacc_corr_accounts = l_param('bacc_corr_accounts'),
        bacc_start_date = l_param('bacc_start_date'),
        bacc_end_date = l_param('bacc_end_date'),
        bacc_comments = l_param('bacc_comments')
      where bacc_id = l_param('bacc_id');
    end if;

  end;
  -----------------------------------------------------------------------
  procedure delete_bank_account(p_bacc_id number) is
  begin
    delete from bas_bank_account where bacc_id = p_bacc_id;
  end;
  -----------------------------------------------------------------------
  function get_manager_acc_list(p_acc_id number) return sys_refcursor
  is
    l_cur sys_refcursor;
  begin
    open l_cur for
    select
      t.man_acc_id,t.acc_id,t.manager_name,t.start_date,
      case when t.start_date = t.end_date then to_date('01.01.2020','dd.mm.yyyy') else t.end_date end end_date,
      t.user_id
    from
    (
      select
        m.*,
        last_value(m.start_date) over
        (
          partition by m.acc_id order by m.start_date  rows between current row and 1 following
        ) as end_date,
        (select u.user_id from bas_user u where m.manager_name = u.user_name and rownum =1) user_id
      from bas_manager_acc m
    ) t
    order by t.acc_id ,t.start_date desc;

    return l_cur;
  end;
  -----------------------------------------------------------------------
  procedure update_manager_acc(p_man_acc_id number,p_start_date date) is
  begin
    update bas_manager_acc set
    start_date = p_start_date
    where man_acc_id = p_man_acc_id;
  end;
  -----------------------------------------------------------------------
  function get_unit_list return sys_refcursor is
    l_cur sys_refcursor;
  begin
    open l_cur for
    select u.unit_id,u.unit_name
    from bas_unit u
    order by u.unit_id;
    return l_cur;
  end;
  -----------------------------------------------------------------------
  procedure update_unit(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) is
    l_param prv_utils.param_t := prv_utils.transform_params(p_names,p_values,'unit_id,unit_name');
  begin
    if l_param('unit_id') is null then
      insert into bas_unit (unit_id, unit_name)
      values (bas_unit_id_seq.nextval, l_param('unit_name'));
    else
      update bas_unit
      set unit_name = l_param('unit_name')
      where unit_id = l_param('unit_id');
    end if;
  end;
  -----------------------------------------------------------------------
  procedure delete_unit(p_unit_id number) is
  begin
    delete from bas_unit where unit_id = p_unit_id;
  end;
  -----------------------------------------------------------------------
  function get_calendar_list return sys_refcursor is
    l_cur sys_refcursor;
  begin
    open l_cur for
    select calendar_id, calendar_descr
    from bas_calendar
    order by calendar_descr;
    return l_cur;
  end;
  -----------------------------------------------------------------------
  procedure update_calendar(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) is
    l_param prv_utils.param_t := prv_utils.transform_params(p_names,p_values,'calendar_id,calendar_descr');
  begin
    if l_param('calendar_id') is null then
      insert into bas_calendar (calendar_id, calendar_descr)
      values (bas_calendar_id_seq.nextval, l_param('calendar_descr'));
    else
      update bas_calendar
      set calendar_descr = l_param('calendar_descr')
      where calendar_id = l_param('calendar_id');
    end if;
  end;
  -----------------------------------------------------------------------
  procedure delete_calendar(p_calendar_id number) is
  begin
    delete from bas_calendar where calendar_id = p_calendar_id;
  end;
  -----------------------------------------------------------------------
  function get_calendar_content_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor is
    l_cur sys_refcursor;
    l_param prv_utils.param_t := prv_utils.transform_params(p_names,p_values,'calendar_id,dcheck1,dcheck2');
  begin
    open l_cur for
    select dcheck, calendar_id, prv_utils.get_message('BAS-CALENDAR_DAY_NAME'||day_num) day_name, count(1) over () cnt
    from bas_calendar_content
    where calendar_id = l_param('calendar_id')
    and (l_param('dcheck1') is null or dcheck >= l_param('dcheck1'))
    and (l_param('dcheck2') is null or dcheck <= l_param('dcheck2'))
    order by dcheck;
    return l_cur;
  end;
  -----------------------------------------------------------------------
  procedure update_calendar_content(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) is
    l_param prv_utils.param_t := prv_utils.transform_params(p_names,p_values,'calendar_id,dcheck');
  begin
    insert into bas_calendar_content(calendar_id, dcheck, day_num)
    values (l_param('calendar_id'), l_param('dcheck'), decode(to_char(to_date(l_param('dcheck'), prv_var.c_sys_datetime_fmt), 'D'), 6, 1, 7, 1, 7));
  end;
  -----------------------------------------------------------------------
  procedure delete_calendar_content(p_calendar_id number, p_dcheck date) is
  begin
    delete from bas_calendar_content
    where calendar_id = p_calendar_id
    and dcheck = p_dcheck;
  end;
  -----------------------------------------------------------------------
  --classifier
  -----------------------------------------------------------------------
  function get_classifier_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor is
    l_cur sys_refcursor;
    l_param prv_utils.param_t := prv_utils.transform_params(p_names,p_values,'entity_id,entity_type');
  begin
    open l_cur for
    select classifier_id, entity_id, kind, type, class
    from bas_classifier
    where (l_param('entity_id') is null or entity_id = l_param('entity_id'))
    and (l_param('entity_type') is null or entity_type = l_param('entity_type'))
    order by kind, type, class;
    return l_cur;
  end;
  -----------------------------------------------------------------------
  procedure update_classifier(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) is
    l_param prv_utils.param_t := prv_utils.transform_params(p_names,p_values,'classifier_id,entity_id,entity_type,kind,type,class');
  begin
    if l_param('classifier_id') is null then
      insert into bas_classifier (classifier_id, entity_id, entity_type, kind, type, class)
      values (bas_classifier_id_seq.nextval, l_param('entity_id'), l_param('entity_type'), l_param('kind'), l_param('type'), l_param('class'));
    else
      update bas_classifier
      set entity_id = l_param('entity_id'),
        entity_type = l_param('entity_type'),
        kind = l_param('kind'),
        type = l_param('type'),
        class = l_param('class')
      where classifier_id = l_param('classifier_id');
    end if;
  end;
  -----------------------------------------------------------------------
  procedure delete_classifier(p_classifier_id number) is
  begin
    delete from bas_classifier
    where classifier_id = p_classifier_id;
  end;
  -----------------------------------------------------------------------
  function get_classifier_kind_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor is
    l_cur sys_refcursor;
    l_param prv_utils.param_t := prv_utils.transform_params(p_names,p_values,'entity_type');
  begin
    open l_cur for
    select distinct entity_type, kind
    from bas_classifier
    where (l_param('entity_type') is null or entity_type = l_param('entity_type'))
    order by 1;
    return l_cur;
  end;
  -----------------------------------------------------------------------
  function get_classifier_type_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor is
    l_cur sys_refcursor;
    l_param prv_utils.param_t := prv_utils.transform_params(p_names,p_values,'entity_type');
  begin
    open l_cur for
    select distinct entity_type, kind, type
    from bas_classifier
    where (l_param('entity_type') is null or entity_type = l_param('entity_type'))
    order by 1, 2;
    return l_cur;
  end;
  -----------------------------------------------------------------------
  function get_classifier_class_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor is
    l_cur sys_refcursor;
    l_param prv_utils.param_t := prv_utils.transform_params(p_names,p_values,'entity_type');
  begin
    open l_cur for
    select distinct entity_type, kind, type, class
    from bas_classifier
    where (l_param('entity_type') is null or entity_type = l_param('entity_type'))
    order by 1, 2, 3;
    return l_cur;
  end;

  -----------------------------------------------------------------------
  function get_next_id(p_sequence_name varchar2) return number is
    l_id number;
  begin
    execute immediate 'select '||p_sequence_name||'.nextval from dual' into l_id;
    return l_id;
  end;
  -----------------------------------------------------------------------
  function get_surcharge_condition_list return sys_refcursor is
    l_cur sys_refcursor;
  begin
    open l_cur for
    select 'Non EU' condition from dual;

    return l_cur;

  end;
  -----------------------------------------------------------------------
  function get_cc_rec(p_cc_id number) return bas_contract_company%rowtype is
    l_res bas_contract_company%rowtype;
  begin
    select *
    into l_res
    from bas_contract_company
    where cc_id = p_cc_id;
    return l_res;
    exception when no_data_found then
      return null;
  end;
  -----------------------------------------------------------------------
  procedure check_rights(p_car_id number, p_entity varchar2, p_entity_id number)
  is
    l_cnt number;
    procedure check_cnt(p_cnt number)
    is
    begin
      if p_cnt = 0 then
        raise_application_error(-20000, prv_utils.get_message('BAS-ERR-ACCESS-TO-ENTITY-DENIED', p_entity, p_entity_id));
      end if;
    end;
  begin

    --Skip check for system owner
    if p_car_id = 1 then
      return;
    end if;


    case p_entity
      when 'product'
      then

        select count(1)
        into l_cnt
        from bas_product p
        where p.product_id = p_entity_id
        and p.product_acc_id in
        (
          select a.acc_id
          from bas_account a
          where a.acc_car_id = p_car_id
        );

        check_cnt(l_cnt);

      when 'account'
      then

        select count(1)
        into l_cnt
        from bas_account a
        where a.acc_id = p_entity_id
        and a.acc_car_id = p_car_id;

        check_cnt(l_cnt);

      when 'agreement'
      then


        select count(1)
        into l_cnt
        from bas_agreement agr
        where agr.agr_id = p_entity_id
        and agr.agr_acc_id in
        (
          select a.acc_id
          from bas_account a
          where a.acc_car_id = p_car_id
        );

        check_cnt(l_cnt);

      when 'poi'
      then

        select count(1)
        into l_cnt
        from bas_voip_poi v
        where v.voip_poi_id = p_entity_id
        and v.voip_poi_product_id in
        (
          select p.product_id
          from bas_product p
          where p.product_acc_id in
          (
            select a.acc_id
            from bas_account a
            where a.acc_car_id = p_car_id
          )
        );

        check_cnt(l_cnt);

      when 'sms_poi'
      then

        select count(1)
        into l_cnt
        from sms_poi sm
        where sm.poi_id = p_entity_id
        and sm.poi_product_id in
        (
          select p.product_id
          from bas_product p
          where p.product_acc_id in
          (
            select a.acc_id
            from bas_account a
            where a.acc_car_id = p_car_id
          )
        );

        check_cnt(l_cnt);

      when 'sms_channel'
      then

        select count(1)
        into l_cnt
        from sms_channel c
        where c.channel_id = p_entity_id
        and c.channel_car_id = p_car_id;

        check_cnt(l_cnt);

      else
        raise_application_error(-20000, prv_utils.get_message('BAS-ERR-UNSUPPORTED-ENTITY', p_entity));
    end case;


  end;
  -----------------------------------------------------------------------
  function get_dnis_ref_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table)
  return sys_refcursor
  is
    l_cur   sys_refcursor;
    l_param prv_utils.param_t;
  begin

    l_param :=
      prv_utils.transform_params
      (
        p_names,
        p_values,
        'id,prefix,first_rec,rec_count,orderby_clause'
      );

    open l_cur for
    select
      dnis_ref_id id,
      dnis_prefix prefix,
      dnis_min_length min_length,
      dnis_max_length max_length,
      decode(rownum, 1, cnt) total_cnt
    from
    (
      select
        r.*,
        row_number() over
        (
          order by prv_utils.get_sort_expression
          (
            l_param('orderby_clause'),
            lpad(r.dnis_ref_id, 20, '0'),
            lower(r.dnis_prefix)
          )
        ) rn,
        count(*) over() cnt
      from bas_dnis_ref r
      where (l_param('id') is null or dnis_ref_id = to_number(l_param('id')))
        and (l_param('prefix') is null or lower(dnis_prefix) like lower(replace(l_param('prefix'), '*', '%')))
    )
    where l_param('first_rec') is null
      or l_param('rec_count') is null
      or (rn >= l_param('first_rec') and rn < l_param('first_rec') + l_param('rec_count'))
    order by rn;

    return l_cur;

  end;
  ------------------------------------------------------------------------------------------
  procedure update_dnis_ref(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table)
  is
    l_param prv_utils.param_t;
  begin

    l_param := prv_utils.transform_params(p_names, p_values, 'id,prefix,min_length,max_length');

    if l_param('id') is not null then

      update bas_dnis_ref set
        dnis_prefix = l_param('prefix'),
        dnis_min_length = l_param('min_length'),
        dnis_max_length = l_param('max_length')
      where dnis_ref_id = to_number(l_param('id'));

    else

      insert into bas_dnis_ref
      (
        dnis_ref_id,
        dnis_prefix,
        dnis_min_length,
        dnis_max_length
      )
      values
      (
        bas_dnis_ref_id_seq.nextval,
        l_param('prefix'),
        l_param('min_length'),
        l_param('max_length')
      );

    end if;

  end;
  ------------------------------------------------------------------------------------------
  procedure delete_dnis_ref(p_dnis_ref_ids dbms_sql.number_table)
  is
  begin

    forall i in 1 .. p_dnis_ref_ids.count
      delete from bas_dnis_ref where dnis_ref_id = p_dnis_ref_ids(i);

  end;
  -----------------------------------------------------------------------------------------------
  function get_dc_pending_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table)
  return sys_refcursor
  is
    l_cur   sys_refcursor;
    l_param prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'record_id,dial_code,orderby_clause');
  begin

    open l_cur for
    select
      record_id,
      dial_code,
      effective_date,
      new_dial_code_country,
      new_dial_code_region,
      new_dial_code_type,
      last_error,
      decode(rownum, 1, cnt) total_cnt
    from
    (
      select
        t.*,
        row_number() over
        (
          order by prv_utils.get_sort_expression
          (
            l_param('orderby_clause'),
            lpad(t.record_id, 20, '0'),
            dial_code,
            to_char(effective_date, 'YYYYMMDDHH24MISS'),
            new_dial_code_country,
            new_dial_code_region,
            new_dial_code_type
          )
        ) rn,
        count(*) over() cnt
      from bas_dial_code_pending t
      where (l_param('record_id') is null or record_id = to_number(l_param('record_id')))
      and (l_param('dial_code') is null or lower(dial_code) like lower(replace(l_param('dial_code'), '*', '%')))
    )
    where l_param('first_rec') is null
      or l_param('rec_count') is null
      or (rn >= l_param('first_rec') and rn < l_param('first_rec') + l_param('rec_count'))
    order by rn;

    return l_cur;

  end;
  -----------------------------------------------------------------------------------------------
  procedure update_dc_pending(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table)
  is
    l_param prv_utils.param_t := prv_utils.transform_params
    (
      p_names,
      p_values,
      'record_id,dial_code,effective_date,new_dial_code_country,new_dial_code_region,new_dial_code_type',
      true
    );
  begin

    check_or_add_country_and_type(l_param('new_dial_code_country'), l_param('new_dial_code_type'));

    if l_param('record_id') is not null then

      update bas_dial_code_pending set
        dial_code = l_param('dial_code'),
        effective_date = l_param('effective_date'),
        new_dial_code_country = l_param('new_dial_code_country'),
        new_dial_code_region = l_param('new_dial_code_region'),
        new_dial_code_type = l_param('new_dial_code_type'),
        last_error = null
      where record_id = to_number(l_param('record_id'));

    else

      insert into bas_dial_code_pending
      (
        record_id,
        dial_code,
        effective_date,
        new_dial_code_country,
        new_dial_code_region,
        new_dial_code_type
      )
      values
      (
        bas_dial_code_pending_id_seq.nextval,
        l_param('dial_code'),
        l_param('effective_date'),
        l_param('new_dial_code_country'),
        l_param('new_dial_code_region'),
        l_param('new_dial_code_type')
      );

    end if;
    
    delete_unused_country_and_type;

  end;
  -----------------------------------------------------------------------------------------------
  procedure delete_dc_pending(p_record_id number)
  is
  begin
    delete from bas_dial_code_pending
    where record_id = p_record_id;

    delete_unused_country_and_type;
  end;
  -----------------------------------------------------------------------------------------------
  procedure apply_pending_dc
  is
    c_proc_name       constant varchar2(256) := 'Apply pending dial codes';
    l_all             pls_integer := 0;
    l_added           pls_integer := 0;
    l_updated         pls_integer := 0;
    l_failed          pls_integer := 0;
    l_task_start_time date := sysdate;
    l_destination     bas_dial_code.dial_code_destination%type;
  begin
  

    for i in 
    (
      select p.*
      from bas_dial_code_pending p
      where effective_date < sysdate
      and last_error is null
      order by effective_date
    ) loop
    
      l_all := l_all + 1;
      
      begin
    
        begin
          select dial_code_destination
          into l_destination
          from bas_dial_code t
          where t.dial_code = i.dial_code;
        exception when no_data_found then
          l_destination := null;
        end;

        if l_destination is not null then
        
          update bas_dial_code t
          set dial_code_country = decode(i.new_dial_code_country, prv_var.c_not_exists_val, dial_code_country, i.new_dial_code_country),
            dial_code_region = decode(i.new_dial_code_region, prv_var.c_not_exists_val, dial_code_region, i.new_dial_code_region),
            dial_code_type = decode(i.new_dial_code_type, prv_var.c_not_exists_val, dial_code_type, i.new_dial_code_type)
          where dial_code like i.dial_code || '%' --Same or longer
          and dial_code_destination = l_destination; --Same destination
          
          l_updated := l_updated + sql%rowcount;
        
        else
        
          insert into bas_dial_code (dial_code, dial_code_country, dial_code_region, dial_code_type)
          select i.dial_code, 
            decode(i.new_dial_code_country, prv_var.c_not_exists_val, null, i.new_dial_code_country), 
            decode(i.new_dial_code_region, prv_var.c_not_exists_val, null, i.new_dial_code_region), 
            decode(i.new_dial_code_type, prv_var.c_not_exists_val, null, i.new_dial_code_type)
          from dual;
          
          l_added := l_added + sql%rowcount;

        end if;
        
        delete_dc_pending(i.record_id);
        
        commit;
        
      exception when others then
      
        update bas_dial_code_pending p
        set last_error = prv_utils.translate_error_msg(dbms_utility.format_error_stack())
        where p.record_id = i.record_id;
        
        l_failed := l_failed + 1;
      
      end;
  
    end loop;

    if l_all > 0 or prv_var.c_debug_mode then
    
      prv_utils.save_debug
      (
        c_proc_name, 
        'Found: ' || l_all || ' records'
          ||'; added dial codes: '||l_added
          ||'; updated dial codes: '||l_updated
          ||'; failed dial codes: '||l_failed
          ||'; spend time='||trunc((sysdate-l_task_start_time)*86400)||' sec.; '
      );
  
    end if;
  
  end;
  -----------------------------------------------------------------------------------------------
  function get_mail_notification_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table)
  return sys_refcursor
  is
    l_param   prv_utils.param_t;
    l_cur     sys_refcursor;
  begin

    l_param :=
      prv_utils.transform_params
      (
        p_names,
        p_values,
        'id,type,time1,time2,subject,status,orderby_clause,first_rec,rec_count,text,cc_id'
      );

    open l_cur for
    select
      notification_id id,
      notification_type type,
      notification_time time,
      notification_status status,
      notification_subject subject,
      null / *dbms_lob.substr(notification_body, 4000, 1)* / text,
      notification_attachment_doc_id doc_id,
      doc_filename,
      notification_cc_id cc_id,
      decode(rownum, 1, cnt) total_cnt
    from
    (
      select
        n.notification_id,
        n.notification_type,
        n.notification_time,
        n.notification_status,
        n.notification_subject,
        n.notification_attachment_doc_id,
        n.notification_cc_id,
        row_number() over
        (
          order by prv_utils.get_sort_expression
          (
            l_param('orderby_clause'),
            lpad(notification_id, 20, '0'),
            notification_type,
            notification_time,
            notification_status,
            lower(notification_subject)
          )
        ) rn,
        count(*) over() cnt,
        d.doc_filename
      from bas_mail_notification n
      left join doc_document d on (d.doc_id = n.notification_attachment_doc_id)
      where (l_param('id') is null or notification_id = to_number(l_param('id')))
        and (l_param('type') is null or notification_type = l_param('type'))
        and (l_param('cc_id') is null or notification_cc_id = l_param('cc_id'))
        and (l_param('status') is null or notification_status = to_number(l_param('status')))
        and (l_param('subject') is null or lower(notification_subject) like lower(replace(l_param('subject'), '*', '%')))
        and (l_param('text') is null or lower(notification_body) like lower(replace(l_param('text'), '*', '%')))
        and (l_param('time1') is null or notification_time >= to_date(l_param('time1'), prv_var.c_sys_datetime_fmt))
        and (l_param('time2') is null or notification_time <= to_date(l_param('time2'), prv_var.c_sys_datetime_fmt))
    )
    where l_param('first_rec') is null
      or l_param('rec_count') is null
      or (rn >= l_param('first_rec') and rn < l_param('first_rec') + l_param('rec_count'))
    order by rn;

    return l_cur;

  end;
  ----------------------------------------------------------------------------------------------------------------------
  function get_mail_notification_text(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return blob
  is
    l_param prv_utils.param_t := prv_utils.transform_params(p_names, p_values, 'id');
    l_text  clob;
  begin

    select notification_body into l_text from bas_mail_notification where notification_id = l_param('id');

    return prv_utils.clob2blob(l_text);

  end;
  ----------------------------------------------------------------------------------------------------------------------
  procedure update_mail_notification(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) -- deprecated. Remove after 3.4.36 and check if everything is okay.
  is
  begin
    update_mail_notification(p_names, p_values, null);
  end;
  ----------------------------------------------------------------------------------------------------------------------
  procedure update_mail_notification(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table, p_text blob)
  is
    l_param       prv_utils.param_t;
    l_time        date;
    l_doc_id      number;
    l_old_doc_id  number;
  begin

    l_param :=
      prv_utils.transform_params
      (
        p_names,
        p_values,
        'id,type,time,subject,text,doc_id,real_file_name,file_name,cc_id'
      );
    l_time := to_date(l_param('time'), prv_var.c_sys_datetime_fmt);

    if l_param('real_file_name') is not null and l_param('file_name') is not null then
      l_doc_id := doc_utils.update_document(p_names, p_values);
    else
      l_doc_id := l_param('doc_id');
    end if;

    if l_param('id') is not null then

      select notification_attachment_doc_id
      into l_old_doc_id
      from bas_mail_notification
      where notification_id = to_number(l_param('id'));
      
      if l_old_doc_id is not null and l_doc_id is null or nvl(l_old_doc_id, -1) != nvl(l_doc_id, -1) then
        doc_utils.update_document(l_old_doc_id, null, null);
      end if;

      update bas_mail_notification set
        notification_type = l_param('type'),
        notification_time = l_time,
        notification_subject = l_param('subject'),
        notification_body = nvl(l_param('text'), prv_utils.blob2clob(p_text)),
        notification_status =
          case
            when l_time < sysdate - c_notif_expiry_period / 24 then
              c_notif_expired
            else
              c_notif_scheduled
          end,
        notification_attachment_doc_id = l_doc_id,
        notification_cc_id = l_param('cc_id')
      where notification_id = to_number(l_param('id'));

    else

      insert into bas_mail_notification
      (
        notification_id,
        notification_type,
        notification_time,
        notification_subject,
        notification_body,
        notification_status,
        notification_attachment_doc_id,
        notification_cc_id
      )
      values
      (
        bas_mail_notification_id_seq.nextval,
        l_param('type'),
        l_time,
        l_param('subject'),
        nvl(l_param('text'), prv_utils.blob2clob(p_text)),
        case
          when l_time < sysdate - c_notif_expiry_period * 24 then
            c_notif_expired
          else
            c_notif_scheduled
        end,
        l_doc_id,
        l_param('cc_id')
      );

    end if;

  end;
  ----------------------------------------------------------------------------------------------------------------------
  procedure delete_mail_notification(p_notification_ids dbms_sql.number_table)
  is
    l_doc_id number;
  begin

    for i in 1 .. p_notification_ids.count
    loop

      select notification_attachment_doc_id
      into l_doc_id
      from bas_mail_notification
      where notification_id = p_notification_ids(i);
      
      if l_doc_id is not null then
        doc_utils.update_document(l_doc_id, null, null); -- delete document
      end if;

      delete from bas_mail_notification where notification_id = p_notification_ids(i);

    end loop;

  end;
  ----------------------------------------------------------------------------------------------------------------------
  procedure send_notifications
  is
    l_attachment  blob;
    l_file_name   varchar2(256);
    l_some_ok     boolean;
    --
    procedure set_status(p_id number, p_status number)
    is
    pragma autonomous_transaction;
    begin
      update bas_mail_notification  set notification_status = p_status where notification_id = p_id;
      commit;
    end;
    --
  begin

    for r in
    (
      select * from bas_mail_notification
      where notification_time <= sysdate
        and notification_status = c_notif_scheduled
        and notification_body is not null
        and notification_subject is not null
    )
    loop

      l_some_ok := false;

      if r.notification_time < sysdate - c_notif_expiry_period / 24 then

        set_status(r.notification_id, c_notif_expired);

      else

        if r.notification_attachment_doc_id is not null then
          begin
            select doc_blob, doc_filename
            into l_attachment, l_file_name
            from doc_document
            where doc_id = r.notification_attachment_doc_id;
          exception
            when no_data_found then
              l_attachment := null;
          end;
        else
          l_attachment := null;
        end if;

        for r1 in
        (
          select car_cc_id, bcc_list
          from
          (
            select
              car_cc_id,
              prv_concat_sum(addr) bcc_list
            from
            (
              select
                car_cc_id,
                addr,
                sum(case when grp < prv_grp then 1 else 0 end)
                over
                (
                  partition by car_cc_id order by rn rows between unbounded preceding and current row
                ) grp
              from
              (
                select
                  car_cc_id,
                  addr,
                  grp,
                  rn,
                  nvl(lag(grp) over (partition by car_cc_id order by rn), 0) prv_grp
                from
                (
                  select
                    car_cc_id,
                    addr,
                    row_number() over (partition by car_cc_id order by car_cc_id) rn,
                    mod((row_number() over (partition by car_cc_id order by car_cc_id)) - 1, 20) grp
                  from
                  (
                    select distinct
                      car_cc_id,
                      decode
                      (
                        r.notification_type,
                        c_ntf_type_acc, agr_fin_alert_email,
                        c_ntf_type_rate, agr_default_rate_change_email,
                        c_ntf_type_inv, agr_default_invoice_email,
                        c_ntf_type_tech, agr_default_tech_email
                      ) addr
                    from bas_agreement
                    inner join bas_account on agr_acc_id = acc_id
                    inner join bas_carrier on acc_car_id = car_id
                    where r.notification_cc_id is null or car_cc_id = r.notification_cc_id
                  )
                  where addr is not null
                )              
              )
            )
            group by car_cc_id, grp
          )
        )
        loop

          begin

            if l_attachment is null then

              prv_mail_utils.send_email
              (
                p_recipient           => null,
                p_subject             => r.notification_subject,
                p_message             => r.notification_body,
                p_message_mime_type   => 'text/html;charset=UTF-8',
                p_mail_server_type_id => prv_mail_utils.c_default_mail_server,
                p_acc_id              => null,
                p_carbon_copy         => null,
                p_blind_carbon_copy   => r1.bcc_list,
                p_cc_id               => r1.car_cc_id
              );

            else

              prv_mail_utils.send_file_by_email
              (
                p_recipient           => null,
                p_subject             => r.notification_subject,
                p_message             => r.notification_body,
                p_message_mime_type   => 'text/html;charset=UTF-8',
                p_file_content        => l_attachment,
                p_file_mime_type      => prv_mail_utils.get_default_mime_type(l_file_name),
                p_file_name           => l_file_name,
                p_mail_server_type_id => prv_mail_utils.c_default_mail_server,
                p_acc_id              => null,
                p_carbon_copy         => null,
                p_blind_carbon_copy   => r1.bcc_list,
                p_cc_id               => r1.car_cc_id
              );

            end if;

            l_some_ok := true;

          exception

            when others then
              null;

          end;

        end loop;

      end if;

      if l_some_ok then
        set_status(r.notification_id, c_notif_successful);
      end if;

    end loop;

    commit;

  end;
  -----------------------------------------------------------------------------------------------
  procedure sleep(p_seconds number)
  is
  begin
    dbms_lock.sleep(p_seconds);
  end;
  ----------------------------------------------------------------------------------------------------------------------
  --Deprecated method---------------------------------------------------------------------------------------------------
  -- Deprecated method since version 3.4.17
  function get_dial_code_country_list
  (
    p_country_pattern   varchar2,
    p_first_rec         number,
    p_rec_count         number
  )
  return sys_refcursor
  is
    l_country_cur sys_refcursor;
  begin
    open l_country_cur for
    select country_id, country_name, country_region_id, decode(rn,nvl(p_first_rec,1),cnt,null) as cnt
    from
    (
      select country_id, country_name, country_region_id, rownum as rn, count(*) over() as cnt
      from bas_dial_code_country
      where (p_country_pattern is null or lower(country_name) like replace(lower(p_country_pattern),'*','%')||'%')
    )
    where rn between nvl(p_first_rec,1) and nvl(p_first_rec,1)+nvl(p_rec_count,999999999)-1
    order by country_name;
    return l_country_cur;
  end;
  -----------------------------------------------------------------------------------------------
  --Deprecated method since version 3.4.17
  function get_carrier_list
  (
    p_name_pattern  varchar2 := null,
    p_direction     number := null,
    p_only_allowed  number := null,
    p_region_id     number := null
  )
  return sys_refcursor
  is
    l_carrier_cur sys_refcursor;
  begin
    open l_carrier_cur for
    select
      car_id, car_name, car_parent_id, have_client_prods,
      have_vendor_prods, car_region_id, car_is_active,
      have_voice_prods, have_sms_prods, have_sms_client_prods,
      have_sms_vendor_prods, car_cc_id
    from bas_carrier
    left join
    (
      select
        acc_car_id,
        max(decode(product_direction, 0, 1)) have_client_prods,
        max(decode(product_direction, 1, 1)) have_vendor_prods,
        max(decode(product_type, prv_var.c_prod_type_int, 1, prv_var.c_prod_type_usdom, 1)) have_voice_prods,
        max(decode(product_type, prv_var.c_prod_type_sms, 1)) have_sms_prods,
        max(case when product_type = prv_var.c_prod_type_sms and product_direction = 0 then 1 end) have_sms_client_prods,
        max(case when product_type = prv_var.c_prod_type_sms and product_direction = 1 then 1 end) have_sms_vendor_prods
      from bas_account a
      inner join bas_product bp on (a.acc_id = product_acc_id)
      group by acc_car_id
    ) on (acc_car_id = car_id)
    where (p_name_pattern is null or car_name like p_name_pattern||'%')
    and
    (
      nullif(p_only_allowed,0) is null
      or (p_direction is null and (car_inbound_allowed+car_outbound_allowed) > 0)
      or (p_direction = 0 and car_inbound_allowed = 1)
      or (p_direction = 1 and car_outbound_allowed = 1)
    )
    and
    (
      p_direction is null
      or (p_direction = 0 and have_client_prods = 1)
      or (p_direction = 1 and have_vendor_prods = 1)
    )
    and
    (
      p_region_id is null
      or car_region_id = p_region_id
    )
    order by car_is_active desc, car_name;

    return l_carrier_cur;
  end;
  ----------------------------------------------------------------------------------------------------------------------
  procedure send_feedback(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table, p_body blob)
  is
    c_recepient constant varchar2(256) := 'feedback@alarislabs.com';
    --
    l_param     prv_utils.param_t;
    l_file_name varchar2(256);
    l_name      varchar2(256);
    l_email     varchar2(256);
    l_cc_id     number;
    l_body      clob := prv_utils.blob2clob(p_body);
  begin

    l_param := prv_utils.transform_params(p_names, p_values, 'subject,file_name');
    
    select
      user_first_name || ' ' || user_middle_name || ' ' || user_last_name || ' (' || user_name || ')',
      (
        select info_value
        from bas_user_info 
        where info_type_code = 'CNT-EMAIL'
          and info_user_id = user_id
      ) email,
      (
        select car_cc_id from bas_carrier where car_id = user_car_id
      ) cc_id
    into l_name, l_email, l_cc_id
    from bas_user
    where user_id = sys_context('user_ctx', 'user_id');

    l_body := 'Company: ' || prv_utils.get_param('FIN-SYSTEM-OWNER-NAME') || '<br>'
      || 'User name: ' || l_name || '<br>'
      || 'User email: ' || l_email || '<br><br>'
      || l_body;

    if l_param('file_name') is null then

      prv_mail_utils.send_email
      (
        p_recipient           => c_recepient,
        p_subject             => l_param('subject'),
        p_message             => l_body,
        p_message_mime_type   => 'text/html;charset=UTF-8',
        p_mail_server_type_id => prv_mail_utils.c_default_mail_server,
        p_acc_id              => null,
        p_carbon_copy         => null,
        p_blind_carbon_copy   => null,
        p_cc_id               => l_cc_id
      );

    else

      prv_mail_utils.send_file_by_email
      (
        p_recipient           => c_recepient,
        p_subject             => l_param('subject'),
        p_message             => l_body,
        p_message_mime_type   => 'text/html;charset=UTF-8',
        p_file_content        => prv_utils.file2blob(l_param('file_name')),
        p_file_mime_type      => nvl(prv_mail_utils.get_default_mime_type(l_param('file_name')), 'application/x-binary'),
        p_file_name           => l_param('file_name'),
        p_mail_server_type_id => prv_mail_utils.c_default_mail_server,
        p_acc_id              => null,
        p_carbon_copy         => null,
        p_blind_carbon_copy   => null,
        p_cc_id               => l_cc_id
      );

    end if;

  exception

    when others then
      prv_utils.save_debug
      (
        'Send feedback',
        'Error:' || ': ' || dbms_utility.format_error_stack() || chr(13) || chr(10) ||
        dbms_utility.format_error_backtrace() || chr(13) || chr(10),
        prv_utils.c_debug_error
      );

  end;
  ----------------------------------------------------------------------------------------------------------------------
  function get_regexp_list(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table) return sys_refcursor
  is
    l_param prv_utils.param_t;
    l_cur   sys_refcursor;
  begin

    l_param := prv_utils.transform_params(p_names, p_values, 'id,name,pattern,descr,orderby_clause');

    open l_cur for
    select
      id,
      name,
      pattern,
      descr,
      decode(rn, 1, count(*) over ()) total_cnt
    from
    (
      select *
      from
      (
        select
          id,
          name,
          pattern,
          descr,
          row_number() over
          (
            order by prv_utils.get_sort_expression
            (
              nvl(l_param('orderby_clause'), 1),
              lpad(id, 20, '0'),
              name,
              pattern,
              descr
            )
          ) rn
        from bas_regexp
        where (l_param('id') is null or id = l_param('id'))
          and (l_param('name') is null or lower(name) like '%' || lower(l_param('name')) || '%')
          and (l_param('pattern') is null or lower(pattern) like '%' || lower(l_param('pattern')) || '%')
          and (l_param('descr') is null or lower(descr) like '%' || lower(l_param('descr')) || '%')
      )
      order by rn
    );

    return l_cur;

  end;
  -----------------------------------------------------------------------------------------------
  procedure update_regexp(p_names dbms_sql.varchar2_table, p_values dbms_sql.varchar2_table)
  is
    l_param prv_utils.param_t;
  begin

    l_param := prv_utils.transform_params(p_names, p_values, 'id,name,pattern,descr');

    if l_param('id') is not null then

      update bas_regexp set
        name = l_param('name'),
        pattern = l_param('pattern'),
        descr = l_param('descr')
      where id = to_number(l_param('id'));
      
      prv_var.m_rows_affected := sql%rowcount;

    end if;

    if sql%rowcount = 0 or l_param('id') is null then
      insert into bas_regexp
      (
        id,
        name,
        pattern,
        descr
      )
      values
      (
        bas_regexp_id_seq.nextval,
        l_param('name'),
        l_param('pattern'),
        l_param('descr')
      )
      returning id into prv_var.m_last_id;
    end if;

  end;
  ------------------------------------------------------------------------------------------
  procedure delete_regexp(p_id number)
  is
  begin

    delete from bas_regexp where id = p_id;

    prv_var.m_rows_affected := sql%rowcount;

  end;
  -----------------------------------------------------------------------------------------------
*/
end;
/
